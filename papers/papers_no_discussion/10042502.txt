
Introduction

We seek to find interactive proofs between quantum provers and classical verifiers, both limited to polynomial-time calculations. That is to say, we would like to have a procedure where a classical computer (the "verifier"), limited to a polynomial number of operations, can query a quantum computer (the "prover"), also limited to a polynomial number of operations, and tap into its resources in order to perform some computation. Additionally, if the verifier unhappily interacts with a malicious quantum computer it should be able to detect this and abort the calculation, even if the prover has unlimited computational resources. To make the challenge less trivial, there should exist interactive proofs for problems that are harder than the verifier could solve by itself and ideally there should exist interactive proofs for any problem that the prover can solve by itself.
This problem is interesting for a variety of reasons. First, as a complexity theoretic question it has obvious value in further developing the theory of how powerful quantum computers are. From a practical computing point of view, it would be nice to know whether it would be possible to have cheap classical computers interact with large (and presumably more expensive) quantum "servers," paying for services as required. Of course the users would like to know that they get their money's worth, and interactive computations can confirm this. As well, from an experimental point of view, interactive proofs can be used to verify the operation of some experimental apparatus. This is of particular importance for quantum experiments since it may well be that, for large experiments, it is impossible (in practical terms) to classically compute what the predictions of the quantum model are, leading to questions about the falsifiability of the quantum formalism {{not_in_s2orc}}.
Very little is known about this problem as stated. Clearly the set of languages recognizable by a poly-time classical verifier and poly-time quantum prover lies somewhere between P and BQP since on one hand the verifier can ignore the prover, and on the other hand the verifier and honest prover together form a poly-time quantum machine. As well, there do exist interactive proofs for all of BQP since BQP ⊆ PSPACE and PSPACE = IP {{not_in_s2orc}}{{32614901}}, but the known constructions require the prover to solve PSPACE-complete problems. Constructions for particular problems are known ( {{15800770}} for example) and of course anything in NP has a trivial interactive proof, but beyond this little is known.
Current techniques [ABG + 07, BLM + 09, MMMO06, MY04, MY98, MYS12,
McK10b, MS12, PAB + 09, PAM + 10, {{not_in_s2orc}} for probing the behaviour of adversarial quantum systems all rely on entanglement and hence in order to make use of them we must introduce more provers. Reichardt et al. {{not_in_s2orc}} considered the case of two provers. Here we will consider the case of a polynomial number of provers, but each limited to a single operation, and show that we can recognize all of BQP with this model. Our construction uses two major components. One is self-testing and the other is measurement-based quantum computation. Self-testing allows us to confirm that the provers hold onto a graph state and perform certain measurements on this state when instructed to do so. Measurement-based quantum computation allows us to use these verified resources to perform the desired calculation.

Previous work

Self-testing was introduced by Mayers and Yao {{16531904}}{{14069874}}. Their goal was to establish that a pair of devices share a maximally entangled pair of qubits, and that the devices implement some specific measurements, all while making a minimum of assumptions on the devices. Specifically they make no assumptions about the dimension of the Hilbert space associated with the devices. Meanwhile, van Dam et al. {{358133}} considered testing gates in the context of known Hilbert space dimension. Magniez et al. {{not_in_s2orc}} combined the two approaches, allowing testing of entire quantum circuits. Further refinements, including simpler proof techniques and extension to complex measurements appear in {{not_in_s2orc}} and {{44939389}}. Self-testing of graph states, critical for our application, appears in {{34099972}}. Miller and Shi {{not_in_s2orc}} also give a general construction for self-testing states based on any XOR game.
These works all require additional assumptions. In particular, they assume that devices can be used repeatedly in an independent and identical manner in order to gather necessary statistics. As well, {{not_in_s2orc}} assumes that certain states are in a product form. McKague and Magniez (in preparation) remove these assumptions for quantum circuits using techniques similar to those used here.
Stemming from a different heritage, Broadbent et al. {{650251}} considered a semi-quantum verifier who only prepares single qubit states, and a fully quantum prover. They give a construction for an interactive proof for any language in BQP. Additionally, they describe (without rigorous proof) an ex-tension using two quantum provers and a classical verifier. Their construction uses measurement-based quantum computation. Aharonov et al. {{not_in_s2orc}} also describe a semi-quantum protocol using a constant sized quantum verifier and a polynomial-time quantum prover.
In the context of quantum cryptography, Acín et al.
[ABG + 07] introduced device independent quantum key distribution. This model is very similar to that used here. However, rather than computation the goal is to expand a private shared key. From a physics perspective, {{not_in_s2orc}} [BLM + 09] and McKague et al. {{118535156}} consider self-testing type entanglement tests from the perspective of Bell inequalities.
Most recently, Reichardt et al. {{not_in_s2orc}} proved a very general result allowing two non-communicating quantum provers along with a classical verifier to recognize all of BQP. The core of their result is a self-test, using only two provers, for multiple EPR pairs and measurements. Using this tool they show how to test individual gates and perform measurements via teleportation. Finally, they combine the results to give an interactive proof for entire quantum circuits.
Measurement-based quantum computation, also known as one-way quantum computation or graph state computation, was introduced by Raussendorf and Briegel {{8839192}}{{6197709}}. In this model of computation we begin with a graph state and perform measurements on each vertex, with the sequence of vertices and the measurement bases used determined by the calculation we wish to make. The outcome of the calculation is then derived from the measurement outcomes. One important aspect of the measurements is that they are adaptive -the measurement basis for a particular vertex can depend on the outcomes of measurements on previous vertices. This allows us to perform any calculation in BQP. The particular variety of graph-state computation that we use is due to Mhalla and Perdrix {{not_in_s2orc}}. The advantage of this model is that it requires measurements in the X-Z plane only.
Contributions

We make several important contributions. First, we modify the proof for the graph state self-test from {{34099972}}, allowing a tighter error analysis. as in {{34099972}}. This exponential improvement in the error scaling in n makes it possible to self-test with a polynomial number of trials to achieve a constant error. We also analyse the error in the case of adaptive measurements, which are required for measurement-based quantum computing. Additionally we extend the graph state test to X-Z plane measurements in order to achieve universal computation. Finally we show how to use the self-test in order to test the provers for honesty in the interactive proof scenario. Combining this test for honesty with measurement-based quantum computation we achieve the following theorem:
Theorem 1. For every language L ∈ BQP and input x there exists a poly(|x|)time verifier V which interacts with a poly(|x|) number of non-communicating quantum provers such that
• If x ∈ L then there exists 1 a set of honest quantum provers, each of which performs a single operation, for which V accepts with probability at least c = 2/3.
• If x / ∈ L then, for any set of provers, V accepts with probability no more than s = 1/3.
Along the way we we also prove several results which may be of independent interest. In particular our error analysis for triangular cluster states can be applied to general graph states and stabilizer states enabling self-testing of these states with robust error bounds. As well, our error bounds for adaptive measurements are quite general, applying to general quantum circuits which incorporate the untrusted measurements performed by the provers.
Compared with the result of Reichardt et al. {{not_in_s2orc}} our contribution is to provide a different construction with different underlying computational model, that of measurement-based quantum computation. While they use a constant number of provers, each of which runs in polynomial time, we use a polynomial number of provers, each of which runs in constant time (indeed, each prover only performs a single measurement). The advantage of our technique is that, since only measurements are used, there is no need for any process tomography. As well, the provers are very easy to implement, requiring only the ability to measure in four different bases (once an appropriate graph state is prepared). Finally, there is a very nice conceptual advantage, which is that the measurement-based calculation that is performed is exactly what would be done with trusted devices, whereas the Reichardt et al. construction requires qubits to be teleported between the two provers at each gate.
Overview of construction

We can divide our interactive proof into two distinct units: the calculation and the test for honesty. The calculation is exactly the same measurementbased quantum computation that would be performed for trusted devices. The test for honesty is derived from self-testing.
We give some technical details of measurement-based quantum computation in section 2.1. The procedure can be summarized as:
1. Prepare a universal graph state 2. Perform measurements to obtain a computation-specific graph state 3. Measure vertices in sequence, adapting bases according to outcomes from previous measurements
Calculate final outcome

In order to perform the computation we need the provers to share a graph state and be able to measure vertices. The verifier performs all the classical computation, including deriving the measurement patterns, the required graph state, and the final outcome.
Our main contributions lie in constructing a test for honesty. Here we must define some test such that if the provers were to cheat on the calculation then they will fail the test. Our test for honesty is based on the graph state self-test, originally presented in {{34099972}}. It allows the verifier to establish that the provers have access to high quality copies of the desired graph state and X and Z Pauli measurements. We give details for this test, including our improved proof in section 3.1.
In addition, for the measurement-based quantum computation we also need measurements covering the entire X-Z plane. This is a simple extension of the graph-state test, which we present in section 3.2.
The graph-state test, with extensions, define a set of subtests, each of which the provers must pass. To administer the entire test, the verifier just chooses one of these subtests at random. If the provers actually hold the required graph state and perform the measurements faithfully then they will pass the test with high probability, and if their behaviour deviates too much from the honest provers then they will pass with a lower probability. The gap is 1/poly(n) for a constant error bound and is calculated in section 3.4.
With all of this in place we obtain a simple statement: if the provers deviate from the honest behaviour by more than δ (see section 2.4 for a definition), then they will pass the test with probability at most c test −ǫ, where ǫ is a function of δ and c test is the probability of honest provers passing the test. Hence if the provers attempt to cheat we will catch them. The details are given in section 3.4.
Having shown how to test whether the provers are honest, and how to perform the desired calculation, we must put these two components together to form the interactive proof. The structure is quite simple: randomly decide whether to check for honesty or perform the calculation and then proceed. The critical observation is that, for an individual prover, the queries received look the same whether the verifier is testing or calculating. More specifically, every query that appears as part of a calculation also appears as part of the test for honesty. Hence the test for honesty catches provers who wish to cheat on the calculation.
The final technical piece of the puzzle is to determine with what probability to test for honesty. We give the derivation in section 4.
Technical introduction

In this section we present some notation and definitions used in the construction and proof. Further technical results are collected in appendix A for convenience.
Measurement-based Quantum Computation

Here we give a general overview of measurement-based quantum computation. Our goal is to provide sufficient background for readers to understand the major features of measurement-based quantum computation. For more detail we refer the reader to {{8839192}}{{6197709}}.
Let us start with a basic teleportation circuit as in figure 1. Rather than performing entanglement swapping with an EPR pair held in memory, as in the usual case, we entangle the input and output qubits directly using a CTRL-X gate. The classical result of the measurement in the X basis is used to control a Z gate, which applies a necessary correction. Direct calculation shows that the input state appears in the output register after the circuit is applied. In the second circuit in figure 1, we convert the CTRL-X gate to a CTRL-Z gate and two Hadamard gates. In the third circuit in figure 1, the left Hadamard simply changes the initial state from |0 to |+ . We move the right Hadamard past the Z correction, which then becomes an X correction gate. Figure 1: Three equivalent basic teleportation circuits. In the second circuit the CTRL-X gate is replaced with a CTRL-Z gate sandwiched between two Hadamard gates. In the third circuit the left Hadamard gate changes |0 to |+ and the right Hadamard gate moves past the Z correction, changing it to an X. Now suppose that we apply a unitary U to the qubit as in figure 2. For this construction we suppose that U(θ) = exp( iθZ 2 ) so that it commutes with the CTRL-Z as in the second circuit of figure 2. Now we can see U as a modification of the measurement basis as in the final circuit. Since we originally measured in the X basis the new measurement basis will be in the X-Y plane of the Bloch sphere: U † XU = R(θ) = cos θ X + sin θ Y . In the second circuit the fact that U(θ) = exp i θZ 2 is diagonal means that it commutes with the CTRL-Z gate. In the third circuit the U(θ) gate has modified the measurement basis to R(θ) = cos θ X + sin θ Y .
Next we consider how multiple teleportations work together. First we consider the case of two cascaded teleportations as in figure 3. Using measurement angles θ 1 and θ 2 , the overall unitary applied by the circuit is HU(θ 2 )HU(θ 1 ). In the second circuit of figure 3 we have moved the second CTRL-Z gate, used to entangled the second and third qubits together, to the left past the X correction on the second qubit. This induces a Z correction on the third qubit, controlled along with the X correction. Finally, in the third circuit we incorporate the X correction into the measurement angle on the second qubit. Indeed, since XR(θ)X = R(−θ), the angle θ 2 becomes −θ 2 whenever an X correction is needed.
We have seen how to convert X corrections into changes in the measurement angle. Z corrections are even easier to apply. Since ZR(θ)Z = −R(θ), a Z correction corresponds to simply inverting the output of a measurement. Figure 3: Two cascaded teleportations. The first circuit teleports the first qubit to the third, applying HU(θ 2 )HU(θ 1 ). In the second circuit we have moved the CTRL-Z to the left past the X correction, inducing a Z correction on the third qubit, but allowing all the CTRL-Z gates to be applied before any measurements are made. Finally, since XR(θ)X = R(−θ) the X correction can be omitted in favour of a change of measurement basis. Figure 4 shows how X and Z corrections together modify the behaviour of the measurement. So far our construction has the following features: we can apply a sequence of unitaries HU(θ n ) . . . HU(θ 1 ) to a qubit by repeatedly teleporting the qubit and varying the measurement angle used in the teleportation. The necessary corrections from the teleportation can be incorporated into subsequent measurement angles and outcomes, and all the entangling CTRL-Z Figure 4: Incorporating X and Z corrections into measurements. We have X and Z corrections according to some previous measurement results x, z ∈ {±1}. The X correction is incorporated into the measurement as a change in the angle. The Z correction is incorporated by flipping the outcome of the measurement.
gates can be pushed to the start of the procedure. Hence we can perform a single qubit circuit by first building a large entangled state using |+ states and CTRL-Z gates, and then measuring the qubits in sequence, adapting measurement angles as we go. Note that the gates HU(θ) form a universal set.
In order to perform general circuits we need one more piece of the puzzle, which is two-qubit gates. In this case we obtain universality by including CTRL-Z gates. These can be applied at any time during the circuit and appear as additional CTRL-Z gates on target qubits when we translate into the teleportation scheme. These can be treated similarly to the CTRL-Z gates which are used to entangle input and output qubits for teleportation. In particular, we can push the CTRL-Z gates back to the beginning of the circuit, past X and Z corrections. This induces extra corrections which must be taken into account on subsequent measurements. Now we have the complete picture. A calculation begins by preparing many |+ states and entangling them with CTRL-Z gates. Then they are measured one at a time, and measurements are adjusted to incorporate X and Z corrections as required.
The initial state, prepared by applying CTRL-Z gates to qubits in the |+ state, is called a graph state and will play an important role in our results here. Our construction will use a slightly different model of measurement-based quantum computation. Although the usual and most easily understood method utilises measurements in the X-Y plane, we will instead use a different model, due to Mahalla and Perdrix {{not_in_s2orc}}, which requires only X-Z plane measurements. In particular they prove the following theorem:
Theorem 2 (Mahalla and Perdrix {{not_in_s2orc}}). Triangular cluster states are universal resources for measurement-based computation based on X-Z plane measurements.
Triangular cluster states are graph states where the underlying graph is a triangular lattice. As we shall see, these particular graph states are particularly easy to self-test since every vertex is in a triangle. The proof of their theorem consists of two parts: showing that triangular cluster states can be converted into other graph states using measurements alone, and showing that X-Z measurements suffice for universal computation. The details of the proof are not important for our results here. What is important is that their construction introduces a small overhead, so that a given quantum circuit gets translated into a graph state with size polynomial in the size of the original circuit.
Operators, isometries, bit strings

We will frequently deal with a tensor product of operators over several subsystems. To make this easier we use the following notation: Definition 1. Given some collection of operators {M j : j = 1 . . . n} with M j operating on the j-th subsystem, and a vector x ∈ {0, 1} n define
(1)
This notation is quite frequently used with Pauli operators, but here we do not assume that the M j operators are all the same. Instead, we merely suppose that there is some common label "M", which may refer to different operators on different subsystems.
Another set of objects that we will deal with frequently is isometries.
Definition 2. An isometry is a linear operator Φ : X → Y that preserves inner products.
Isometries are a natural generalization of unitaries where the image space of ⊕ is not necessarily the same as X , and may in general have a larger dimension. As a concrete and pertinent example, adding an ancilla prepared in a particular state and applying a unitary are both isometries, as is their composition. Isometries are naturally extended to the dual space by Φ( ψ|) = Φ(|ψ ) † and to operators by Φ(|x y|) = Φ(|x )Φ( y|), plus linearity.
As we shall see, we will need to address the state spaces of provers individually, se we will need the concept of a local isometry.
Definition 3. A local isometry on n subsystems is an isometry of the form
where Φ j operates on the j-th subsystem only.
Here a tensor product of isometries is evaluated in a way analogous to how a tensor product of unitaries is applied: decompose the state into a sum of product states and apply the operator to the appropriate vector in the tensor product. That is to say,
(3)
From this it is easy to derive the following properties of local isometries.
Lemma 1. Let Φ = Φ 1 ⊗ Φ 2 be a local isometry, |ψ 1,2 be a bipartite state, and M 1 be a local operator on the first subsystem. Then
We make extensive use of bit strings. For an n-bit string t the j-th bit is t j . Inner products of bit strings are given by
We will, at times, consider the inner product as an integer, and at other times as a bit (i.e. over Z or Z 2 ). Where the difference is important we will specify. For example, t · t taken over Z gives the number of ones in t but when taken over Z 2 it is the parity of the number of ones. Finally, we define the bit string 1 v to have a one only in the v position and zeros elsewhere, i.e. (1 v ) j = δ vj .
Graph states

We assume that the reader is familiar with the basics of graph theory. A good resource is {{not_in_s2orc}}. We now fix some notation for our convenience. Let
In other words, the induced subgraph is the maximal subgraph of G on vertices in S.
The graph state |G is an n-qubit state, with qubits labelled by vertices, which is stabilized by the operators
That is, S v has X on vertex v and Z on each of its neighbours and
Equivalently,
To explain, let us write
Now since A u,v = A u,v = 1 whenever (u, v) ∈ E, we are counting edges. The summation and A are symmetric, so we are double counting and we always get an even number (hence the 1 2 appearing in the exponent above). Let T x = {v|x v = 1}, then we are summing over all the vertices in T x , double counting the edges in the induced subgraph.
For completeness we show that the above two definitions are equivalent by showing that |G is stabilized by S v :
where we have re-indexed the summation by x → x ⊕ 1 v . The ± in the exponent of the −1 represents the fact that we only care about the parity of the exponent, so we can add or subtract as we please.
There are two cases. First, if v ∈ T x then T x⊕1v does not contain v. The subgraph on T x is obtained from the induced subgraph on T x⊕1v by adding v and all the associated edges, x · A1 v of them, and the total number of edges in the induced subgraph on T x is
In the other case v / ∈ T x , so we obtain T x by removing v and all associated edges from T x⊕1v , so
Hence
We have shown that the operators S v stabilize |G . It is also easy to see that the S v operators are independent: any one cannot be obtained by multiplying together others. They also commute with each other. We then have n independent, commuting n-qubit Pauli operators which stabilize a 1-dimensional space {{not_in_s2orc}}.
Operationally, graph states are constructed by beginning with the qubits in the state |+ ⊗n and applying CTRL-Z gates on vertices u, v whenever (u, v) ∈ E.
The above reasoning will be important later on. In particular, we can apply (13) and (14) repeatedly over all v such that y v = 1 to prove the following lemma.
Definition for "closeness"

We will need to establish that the state held by the provers is "close to" a given graph state and that the measurements they perform are "close to" the ideal X-Z plane observables. However, there are many transformations that the provers can apply to both states and measurements which are invisible to the verifier. In particular, the provers may add an ancilla or apply a local change of basis (simultaneously to both the state and measurements). In fact, we will see that for the states and observables we use these are the only undetectable transformations that they can apply 2 . We can account for such transformations by allowing an arbitrary isometry which undoes these transformations and presents us with the required graph state plus some arbitrary ancilla state. We also allow for some noise by comparing states in the usual vector norm.
Definition 4. {{not_in_s2orc}} We say that a multi-partite state |ψ ′ and observables {M ′ } are ǫ-equivalent to |ψ and {M} if there exists a local isometry Φ and a state |junk such that for every M
Here we are thinking of "M" as both the ideal operation on |ψ and as a label for the operation M ′ .
Evidently this definition guarantees that the two systems behave like each other since isometries preserve inner products, and hence outcome probabilities. As we shall see, it is also a necessary condition for states and measurements to behave close to the ideal graph states and X-Z plane measurements. Hence any other definition we could choose is at most a different characterization of the errors and in the exact case is equivalent. The error bound used here has an operational meaning since we can quickly bound the error in outcome distributions from it.
There is one shortcoming of this definition, which is that it is impossible to test states or operators which contain any imaginary component in the ideal case (this restriction does not apply to the states and operators held by the provers, only to the ideal that we compare them to.) The simple reason is that the provers may apply a complex conjugation to everything without changing the distribution of their responses to the verifier. This transformation is not an isometry, and hence it is impossible to conclude that any system satisfies the above definition based on classical interaction alone. It is, however, possible to extend the definition to account for this case {{44939389}}. We do not need to use this extended definition here since all our ideal operators and states are real.
Modelling the provers

An important argument in our work is that we can model the provers, even in the dishonest case, by a pure joint state held by the provers, and a collection of observables for each prover, one per possible query to that prover.
First, it should be clear that it is not a restriction to consider pure states. Any mixed state can be purified and the purification given to any one of the provers. This only increases the power of the provers by giving them additional information held in the purification.
Next, since our provers will only receive one query and respond with one message, we can model their actions by a measurement. Any pre-processing done before the measurement can be incorporated into the choice of measurement along with any post-processing. Further, since we are not making any assumptions on the dimension of the state held by the provers, their measurements can be taken to be projective and, since the provers will always respond with ±1 the projectors can be combined into an observable without any loss of information or generality.
Finally, we must consider how the provers will behave knowing that some of the time they will be tested and some of the time they will be asked to perform the calculation. As well, in certain cases the provers will know for certain that they are being tested, although they will never be able to conclude that they are certainly taking part in the calculation. The provers know in advance the list of possible query strings (there are only four) and whatever their strategy, they use some physical processes to decide on their output. We then roll this process into the measurement observable, so that each possible query string corresponds to a single observable which represents the entire strategy of the prover.
Test for honesty

In order to develop a test for honesty we go through several steps. The first step is to develop a test for graph states. This is the foundation on which we build the test for honesty. After showing how we can verify that the provers hold onto a particular graph state we then show how to test measurements in the X-Z plane. Adaptive measurements built on measurements in the X-Z plane are the next step. Finally, we put all of the tests together into a single test and show how the probability of passing this test relates to the amount of error in an adaptive measurement performed on the same state and using the same measurements.
Self-test for triangular cluster states

In this section we develop a self-test for triangular cluster states. The techniques used are similar to those in {{34099972}}. However, we make some modifications which allow for a tighter error analysis and clearer notation. Although we give the construction for triangular cluster states only, the same techniques can be extended to work with any stabilizer state, as in {{34099972}}.
Theorem 3. Let G be a triangular grid graph on n vertices with adjacency matrix A and let ǫ > 0. Further, suppose that for an n-partite state |ψ ′ with local measurements
and for each triangle
then there exists a local isometry Φ and state |junk such that
We may interpret Theorem 3 as follows: for each triangular cluster state there exists a set of non-local correlations that uniquely identifies that graph state and X and Z measurements, up to local unitaries and additional ancillas.
The proof can be divided into several sections. The final goal is to construct an isometry Φ and prove that it takes the state close to the desired graph state. The construction for the isometry is given in terms of the X ′ and Z ′ operators on each vertex. To bound the error we need to know how these operators behave and in particular that they approximately anti-commute. This is done in Lemma 3 and corollary 1. For the final proof we will also need to get rid of some X ′ operators. In the ideal case we can use the stabilizers:
In Lemma 4 we show that this, and a generalization to many X's, is also approximately true for the primed operators. With these estimations in place we the proceed with the proof of Theorem 3.
Preliminary technical estimations

Our graph G is a triangular lattice, so every vertex lies in a triangle. For self-testing this gives a nice advantage, since it is particularly easy to show that X ′ and Z ′ anti-commute for vertices in a triangle.
Proof. First, let T = {u, v, w} be a triangle containing v. The first part of Lemma 9, together with the conditions of Theorem 3, tell us
for x ∈ {u, v, w}, and from triangle τ
Applying the second part of Lemma 9 three times to combine these, we find
The Z ′ s operating on vertices outside T all cancel since they appear in S ′ x and in Z ′A1u for some x ∈ {u, v, w} and there are no X ′ operators outside the triangle. We are left with
Examining how the operators commute with each other, we can pair up and cancel the X ′ x and Z ′ x for x ∈ {u, w}, resulting in
Rearranging by multiplying by Z ′ v X ′ v , we obtain our result. Note that it is sufficient to consider a set of triangles that covers the set of vertices and hence Theorem 3 holds for all graphs in which each vertex is contained in a triangle. In fact, as in {{34099972}}, it is sufficient to consider one triangle or just one edge in a connected graph, but this will give a less robust result. Lemma 2 in {{34099972}} shows that if X ′ v and Z ′ v approximately anti-commute, then so do X ′ u and Z ′ u for some neighbour u of v. Using this one can induct along paths to all vertices in a connected component. For our purposes this is unnecessary since all vertices lie in at least one triangle.
The above lemma can be generalized to products of operators, as in the following corollary.
Corollary 1. Let s, t ∈ {0, 1} n . Under the conditions of Theorem 3,
where s · t is taken over Z.
This can be seen by repeatedly applying Lemma 3, once for every v such that s v = 1 = t v , and using the triangle inequality. If s x = 1 but t x = 0, or vice versa, for some x ∈ V , then the single operator on vertex x commutes with all other operators. Now we consider the physical "stabilizer generators" S ′ v . The conditions of Theorem 3 establish that they really are (close to) stabilizers of |ψ ′ . Next we consider products of these generators and show that they too almost stabilize |ψ ′ .
Lemma 4. Let t ∈ {0, 1} n . Under the conditions of Theorem 3,
where At is evaluated over Z 2 and t · At and t · t are evaluated over Z.
Proof. First, by Lemma 9 we find
The right term can be expanded as v∈V tv=1
We fix an ordering < on V , and evaluate the product according to that ordering. Thus if t v = t u = 1 and u < v then S ′ u appears in the product to the left of S ′ v . Now suppose that A uv = 1. Then Z ′ u in S ′ v appears to the right of the only occurrence of X ′ u in S ′ u . We may commute Z ′ u to the right past all remaining operators on the u system, so that Z ′ u appears to the right of all X ′ operators. The opposite is true if v > u, in which case we may commute Z ′ u to the left, and it appears to the left of all X ′ operators. Thus we may write the above as
Let A L be the lower triangular part of A (with 0s elsewhere) and A U the upper triangular part. Then we may rewrite the above as
Using corollary 1 we obtain
Noting that A U t + A L t = At and t · A L t = 1 2 (t · At) since A is symmetric, we apply the triangle inequality along with (31) to find
which is readily transformed into the desired result by multiplying by X ′t .
Proof of Theorem 3

We are now in a position to prove Theorem 3. This is done by giving a construction for Φ and using the above lemmas to prove that it has the necessary properties. Figure 5: Circuit for Φ v Proof. We will use Φ v as defined in figure 5. The circuit is modified from that used in {{34099972}}{{118535156}} and earlier works, differing in the state of the ancilla. Whereas we use an entangled pair of qubits |φ + , previous works used |0 . We also add an initial CTRL-X gate which was not needed when the initial state was |0 . When X ′ v and Z ′ v are the Pauli X and Z gates the circuit is clearly a SWAP gate. The idea is to swap the hidden qubit in the input wire with an explicit qubit. As we shall see, the use of a maximally entangled pair of qubits in the ancilla wires allows for a tighter robustness analysis than is possible with the earlier version of the circuit.
The structure of the proof is a sequence of chained inequalities between states |ψ j and |ψ j+1 for j = 1 . . . 4 defined below. We then use the triangle inequality to find the total distance. We define Φ = v∈V Φ v , and |ψ 1 = Φ (Z ′p X ′q |ψ ′ ) to be the state after the isometry Φ is applied. Using Lemma 12 this becomes
where s, t, u ∈ {0, 1} n . The first step is to move Z ′p to the left using corollary 1, obtaining
Next we move the combined Z ′ s back to the right using corollary 1 again:
Moving Z ′ to the left past the combined X ′ s using corollary 1 one last time, we define |ψ 4 by
Now make two changes of variable, t → t ⊕ p and u → u ⊕ q, arriving at 1 √ 2 3n s,t,u (−1) t·s (−1) p·u Z ′t X ′u⊕s |ψ ′ |s |u ⊕ q .
Next we replace the X ′ s with Z ′ s using Lemma 4
s,t,u (−1) t·s (−1) p·u (−1) 1 2 (u⊕s)·A(u⊕s) Z ′t⊕A(u⊕s) |ψ ′ |s |u ⊕ q .
after which the state factorizes:
In the case where ǫ = 0 the above essentially gives the entire proof. The remainder of the proof estimates the error at each step.
First we note that all the states above are normalized. In all cases this is easy to prove. We show the calculation for |ψ 2 , with the others proceeding similarly. We find
The su|s ′ u ′ factor implies that u ′ = u and s ′ = s for all non-zero terms so
The X ′u operators square to the identity, and subsequently so do the Z ′p s.
We then make a change of variable t ′ → t ′ ⊕ t and break (−1) t·(s⊕u) into (−1) t·s (−1) t·u . The summand no longer depends on t ′ so we can omit it from the summation, multiplying by 2 n instead. We also bring the summation over u inside, forming an inner sum.
1 2 2n
Lemma 10 says that the inner sum is 0 except when t = 0, so we can drop the Z ′t s and the summation over t, and t·s = 0. Then the X ′s⊕q s then square to the identity. We are left with 1 2 n s ψ ′ |ψ ′ = 1. Now we estimate the distances between successive states starting with |ψ 1 and |ψ 2 . From the definition of the 2-norm,
Next we determine ψ 1 |ψ 2 :
From the su|s ′ u ′ term, we see than s = s ′ and u = u ′ in all non-zero terms. This allows us to cancel X ′u X ′u ′ and remove the u ′ and s ′ variables. We also pull the sum over u in as an inner sum 1 2 3n
(52) Next we use Lemma 10 to see that the inner sum is zero except when t⊕t ′ = 0. The terms (−1) (t⊕t ′ )·s) and Z ′t⊕t ′ then become 1 and the identity, leaving the summand independent of t and t ′ . We remove them from the sum, multiplying by 2 n instead. Finally, we make the change of variable s → s ⊕ q to get 1 2 n s (−1) p·s ψ ′ |Z ′p X ′s Z ′p X ′s |ψ ′ .
Next set ǫ p,s = ψ ′ |Z ′p X ′s Z ′p X ′s |ψ ′ − (−1) p·s ψ ′ |Z ′p X ′s X ′s Z ′p |ψ ′ , with the second term becoming just (−1) p·s , so that the above becomes
Corollary 1 and the third part of Lemma 9 give |ǫ p,s | ≤ 4(p·s) √ 2ǫ. Lemma 11 tells us how to deal with the sum over s, and we write
and plugging this back into the definition of the 2-norm gives
Using similar estimates we find
where the final sum is over s and t rather than s with the fixed string p. We appeal to the second part of Lemma 11 as the last step.
The remaining distance to calculate is |||ψ 4 − |ψ 5 ||. Again we proceed by way of the definition of ||·|| and the inner product.
For non-zero terms s = s ′ and u = u ′ . Re-indexing by s → s ⊕ u we find that the above is equal to
where we have pulled all the terms dependent on u into the inner sum. Lemma 10 says that this inner sum is zero except where t ⊕ t ′ = 0 when it is 2 n . Substituting these in, the above becomes
Now let us bound the inner product:
To obtain the second line above we have used the triangle inequality. The third line comes from applying Lemma 4 and Lemma 9. We then use Lemma 11 to obtain the last line. Finally we find
Adding all the bounds using the triangle inequality we obtain
Error bounds for non-Pauli measurements

In order to achieve universal computation we need to have measurements other than just X and Z. It suffices to have X-Z plane measurements. Let us define
We use the symbol R ′ u (θ) to denote the ±1 eigenvalue observable that the prover uses when queried with the angle θ. We do not make any prior assumption on how R ′ u (θ) is related to X ′ u or Z ′ u . Instead we will derive said relationship via the graph-state test and further measurements.
Lemma 5. Under the conditions of Theorem 3, if we have measurements R ′ v (θ) and an edge (u, v) such that
then with Φ and |junk set to those in Theorem 3,
where δ is the bound in Theorem 3
Proof. From Theorem 3 we obtain Φ and |junk so that
for M ′ ∈ {Z ′A1v , X ′ u Z ′A1u⊕1v } in particular. From the stabilizer generators S u and S v we find X u Z A1u⊕1v |ψ = Z v |ψ and Z A1v |ψ = X v |ψ , hence linearity of Φ and the triangle inequality give
Using cos θ X v + sin θ Z v = R v (θ) and cos θ + sin θ ≤ 2 this becomes
Now since || ψ ′ |R ′ v (θ)|| ∞ = 1, and Φ preserves inner products, we have
Using the triangle inequality and (69) we find
We now apply Lemma 9 to obtain the desired bound.
The lemma says that if we can estimate the expected value for a certain operator we can bound the error on R ′ u (θ). Later in section 3.4 we will show how we can estimate said expected value.
Error bounds for measurement patterns

Our bounds in the previous section show that we can bound the error when applying a measurement of the form M 1 ⊗ · · · ⊗ M n , which gives a single bit of output. However, for graph state computation we need something much more substantial since we will need to measure the subsystems in a sequence, with each basis chosen as a function of the previous outcomes. In fact we will prove something even stronger than this.
We will consider a stronger situation where instead of trusted classical computation and classical interaction, we have some trusted quantum computation and quantum interaction with the provers. The provers allow the basis to be chosen quantumly and they similarly return the result coherently. We can model this by specifying that, when queried with a quantum register, prover j applies
where M ′ j,k corresponds to the observable that prover j uses when queried with input k ∈ {0 . . . m j }. The prover then passes the control register back to the verifier and the result of the query is stored as a ±1 phase. We will require that the prover's actions are all of this form, although they are free to choose the M ′ j,k as they like. As well, the ideal operator V j has this form, using observables M j,k .
Assuming 4 M ′ j,0 = I we can retrieve the outcome for measurement M ′ j,k by preparing the state 1 √ 2 (|0 + |k ) and observing the relative phase change in the prover's response. Hence this model includes the original classical behaviour as a particular case.
A general circuit for the verifier-prover interaction in this stronger model is given in figure 6. The verifier first applies some unitary U 0 to prepare its initial state, and then performs the first query to prover 1, V ′ 1 . The verifier then applies some unitary U 1 to its internal state and performs the second query to prover 2, V ′ 2 , and so on. The combined operation is U n V ′ n . . . U 1 V ′ 1 U 0 . We require that each V ′ j is applied at most once and for convenience we suppose that they are numbered in the order in which they are applied. In this circuit we have always used the same the control wire, which is a q-dit with dimension equal to the maximum m j + 1. This is not a limitation since we can always use the same control wire by incorporating swaps into the U's if necessary.
. . . Figure 6: Semi-trusted circuit incorporating untrusted measurements by the provers,
That is, W ′ j represents running the circuit until the point after U j has been applied. Similarly, let W j be the ideal circuit where we substitute in the ideal V j (constructed from the ideal M j,k ).
Lemma 6. Let |ψ , |ψ ′ , |junk , and Φ = Φ 1 ⊗ . . . Φ n be given along with M ′ j,k and M j,k (k = 0 . . . m and M ′ j,0 = I) such that
Further, let some |φ and U j be given where |φ contains a register of dimension at least m + 1 and U j acts only on the |φ registers, and let, V j , V ′ j , W j and W ′ j be defined as above. Then
The intuition is that each V ′ j is the sum of operators |k k| ⊗ M ′ j,k , each of which is close to the corresponding ideal operator. We can then use the triangle inequality to say that V ′ j as a whole is close to its ideal counterpart. Inducting over the depth of the circuit gives the desired result.
Proof. The proof proceeds by induction. For the case n = 0 we have not yet applied any untrusted gates and the conclusion is true by taking inequality (77) and multiplying by the trusted gate U 0 . Now let us suppose that (78) holds for n − 1. We start by using the bound (77) with (j, k) = (1, 0) to get
For each k = 0 we multiply by the bound on both sides by Φ n (M ′ n,k ) to obtain inequalities
By Lemma 1 Φ n (M ′ n,k )Φ(|ψ ′ ) = Φ(M ′ n,k |ψ ′ ), so the state on the right above is close to |junk M n,k |ψ by (77) with (j, k) = (n, k). Using the triangle inequality we find
We introduce the register |φ and apply the ideal unitary W n−1 to both sides in the above estimation without increasing the distance. On the left, since Φ n and M ′ n,k only operate on the nth subsystem, Φ n (M ′ n,k ) operates only on the nth subsystem of |junk |ψ (i.e. on the nth subsystem of |junk together with the nth subsystem of |ψ ). Then since W n−1 operates only on the trusted system and the first n − 1 subsystems of |ψ , it commutes with Φ n (M ′ n,k ) and M n,k so Φ n (M ′ n,k )|junk W n−1 |ψ |φ − |junk M n,k W n−1 |ψ |φ ≤ 2δ (82)
Now we apply the projection |k k| (used in the expression for V ′ n ) to both sides, again without increasing the distance. Hence
Summing over all k using triangle inequality, we apply the definitions of V j and V ′ j to arrive at
Note that it is 2mδ and not 2(m + 1)δ since the case k = 0 has no error by assumption. The state on the right above is almost what we want. Now we invoke the induction hypothesis, (78) with n − 1 and multiply through by
and applying the triangle inequality to the above two estimates we get
Multiplying by the trusted gate U n finishes the proof.
In order to use this lemma we do not need the full generality of Theorem 3. We only need it to apply for individual measurements rather than the full set X p Z q .
For our purposes we do not need the full strength of the lemma. We need only know that adaptive measurements give correct outcomes.
Corollary 2. Let |ψ , |ψ ′ , |junk , and Φ = Φ 1 ⊗ . . . Φ n be given along with M ′ j,k and M j,k (k = 0 . . . m and M ′ j,0 = I) such that
Then for any adaptive measurement made using the M ′ s, the probability of a particular outcome differs from the ideal case by at most 2(2nm + 1)δ.
Proof. We can represent an adaptive measurement as a circuit W n as in Lemma 6. Hence
To obtain the classical outcome we perform some measurement on one of the trusted subsystems. Without loss of generality this can be a projective measurement, so let Π x the projector for outcome x, which acts non-trivially only on the trusted subsystem. The probability of outcome x is then
Now to estimate this probability we use (88) above in two different ways. First, multiplying on the left by Φ( ψ ′ | φ|W †′ n ) we get
Second, multiplying (88) on the right by junk|W † n ψ| φ| and then taking the adjoint of the resulting expression we obtain
(91) Adding these together using the triangle inequality and invoking the fact that Φ preserves inner products we find
In other words, the probability of finding outcome x differs from the ideal case by at most 2(2mn + 1)δ.
A one-shot test

As stated, the self-testing results are not terribly useful to us. They require knowledge of the expected value of various operators in order to draw any conclusions. The obvious solution is to take some samples and estimate, but this would require either some independence assumptions or additional work with, for example, martingales. Instead we will work with the contrapositive of the self-testing results: if the state and/or some measurements are far away from the ideal, then some measurable expected value will also be far away from the ideal. Although this is logically equivalent, instead of requiring lots of information about the various measurements, we instead are told that we just have to look for one measurement that is misbehaving. As well, we are going to arrange our measurements in a particular way as a test for honesty. For example, the stabilizer measurements will always return 1 for honest provers, so if we perform this measurement and we get a 1 the provers pass the test. If result is -1 then they fail the test. As the expected value gets close to 1, the provers will pass with probability close to 1. If the expected value is far away from 1, the provers will fail the test with some probability. Now with the R(θ) measurements we do not have the same situation, but we do have something just as useful. We can build a compound test so that the ideal honest provers pass with some probability, and no other provers can pass with a higher probability. This is analogous to the CHSH test: the ideal quantum strategy passes with probability ≈ 0.85, and no other strategy achieves any higher success rate. As well, cheating provers will pass the test with a probability that is bounded away from the quantum limit, and so we obtain a gap between the ideal and cheating strategies. The honest provers will fail the test some of the time, but this is no problem: we will later do some repetition so that the ideal provers will pass with an overall probability that can be made arbitrarily close to 1. Now we give the construction for our one-shot test. First, let T be a set of triangles that covers V , i.e. each vertex in V appears in at least one triangle in T . The triangles will be specified by characteristic vectors τ . Let N G = 3|V | + |T |. Note that N G ≤ 4n since we need no more than n triangles to cover V .
For a graph state computation we need only two different measurement angles per vertex, ±θ v . As well, the measurement angle θ v + π can be simulated by measuring with angles θ v and flipping the outcome. Hence there is no loss of generality by assuming that 0 ≤ θ v ≤ π so that cos θ v ≥ 0.
The test procedure is as follows:
Procedure 2 (One-shot test for graph states and measurements).
1. Randomly select either "VERTEX" with probability |V | N G , "TRIANGLE" with probability |T | N G , or "RTHETA" with probability 2|V |
ii. Accept if the product of the replies is 1, otherwise reject
Accept if the product of the replies is 1, otherwise reject.
To clarify, if the basis for a prover is I then we simply ignore that prover, and its "reply" is taken to be 1.
The test is naturally grouped in to N G different subtests. From the graph state test we have |V | subtests testing the "physical stabilizers", and |T | subtests testing the triangles. Additionally, there are 2|V | "RTHETA" subtests, one for each choice of v and t. Each of these consists of two queries chosen according to some random coin.
Lemma 7. Let n non-communicating quantum provers be given that each take one of four measurement bases, labelled X, Z and R v (±θ v ) as inputs and measure joint state |ψ ′ according to operators in
Then then procedure 2 accepts with probability at most
and if there exist v and
then procedure 2 accepts with probability at most
Proof. Honest case. First let us derive the maximum probability of passing the test. This is attained in the honest case. The "VERTEX" and "TRI-ANGLE" subtests can all be passed simultaneously with probability 1 in the honest case since the observables are all in the stabilizer group of the graph state.
Let us now consider the "RTHETA" subtests. First, we fix a vertex v. The queries to the in the provers in the test can be seen as one large random variable taking values ±1 and having the expected value
Note the similarity to the CHSH correlation, which is obtained for θ v = π 4 . The honest provers will attain an expected value of 1 2(cos θv+| sin θv|) . To see this, we notice that Z A1u |ψ = X u |ψ and X u Z A1u⊕1v = Z v |ψ , which we obtain from the stabilizers S v and S u . Applying the definition of R(θ), the expected value becomes
Now we show that this is in fact the maximal quantum expected value. Using a standard technique introduced by Cirel'son {{120680226}}, the maximum value is the same as 1 2(cos θ v + | sin θ v |) max |ψ 1 ,|ψ 2 ,|φ 1 ,|φ 2
where the maximization is taken over normalized states, all of dimension four. Clearly the maximum is found when |ψ 1 is taken to be in the direction of cos θ v |φ 1 + sin θ v |φ 2 and |ψ 2 is in the direction of cos θ v |φ 1 − sin θ v |φ 2 . In this case the value becomes
Expanding using the definition of ||·|| we obtain
We next use the identity cos θ sin θ = 1 2 sin 2θ to get
which attains the value of 1 cos θv+| sin θv| when φ 1 |φ 2 = 0. We now have the expected value of the honest case and a matching upper bound. The expected value of any ±1 valued random variable X is related to the probability of obtaining 1 (i.e. the "success" probability) by Prob(X = 1) = X 2 + 1 2 .
(103) So the probability of success for the "RTHETA" portion of the test for a specific v is bounded above by
Combining this with the maximum probability of success for the "VER-TEX" and "TRIANGLE" subtests, the overall maximum probability of success for any set of quantum provers, attained for honest provers, is
The factor 2 in front of the summation represents the fact that for each v the "RTHETA" subtest occurs with probability 2/N G . Dishonest case Now that we have an upper bound, we translate the probability of success into an error bound on the expectation value of each subtest.
From now on fix a set of provers, which fixes the observables and state. Suppose that the provers pass the test with probability c test − ǫ 2N G . Then each "VERTEX" or "TRIANGLE" subtest passes with probability at least 1 − ǫ/2, which is obtained when all the error happens on a single subtest. This means that the expected value for the corresponding random variable is 1−ǫ and the conditions for Theorem 3, (20) and (21) are satisfied. Hence (94)
where we have used the estimations p · p ≤ 1, since this is all we need to apply corollary 2, and |E| ≤ 3n, since we are using a triangular cluster state which has a maximum degree of 6. For the "RTHETA" subtests, fix a v. As above, the expected value for the corresponding ±1 random variable is at least c v test − ǫ. Hence the conditions of Lemma 5 are satisfied for each v and ±θ. Then equation (94)
where we have used ǫ ≤ ǫ 1 4 for 0 ≤ ǫ ≤ 1. When δ ≤ 1 the error for the R ′ v (±θ v ) will be larger, so we will use this value.
We have just shown that if the provers pass the test with probability at least c test − ǫ 2N G then the left side of (94) is bounded by δ as above (i.e. (94) is false). This is the contrapositive of our desired result which is that, if (94) is true, then the probability of passing is at most c test − ǫ 2N G . So we need only solve for ǫ in terms of δ. We find
Now the probability of passing is at most c test − ǫ 2N G , which is bounded above by
This one-shot test gives us an error bound on the states and measurements. Combining this with Lemma 6 we can relate the probability of passing the test to the error in an adaptive measurement, i.e. our final measurementbased quantum computation.
Corollary 3. Let a set of quantum provers be given where prover v takes in-
For honest provers, procedure 2 accepts with probability
For general provers, if for any adaptive measurement pattern the probability of any outcome on the provers' final outcome differs from the ideal by more then δ then procedure 2 accepts with probability no more than
Proof. By corollary 2, if we achieve error less than δ ′ = δ 2(8n+1) on equation (87) then we are done, since m = 4 here. Lemma 7 says that we can achieve this if the provers pass with probability no more than
≥ δ 8 10 18.1 n 11 (119) using the pessimistic bounds N G ≤ 4n and 1 ≤ √ n ≤ n. Hence if the provers pass with probability less than
we obtain our desired result.
Interactive proofs

We are now in a position to construct an interactive proof for any language in BQP. To this end, let L be a language in BQP. Then from Theorem 2 and the definition of BQP for any input x there exists an adaptive measurement 5 on a polynomially sized triangular graph state such that
• If x ∈ L then the measurement outputs "ACCEPT" with probability c calc ≥ 2 3 . • If x / ∈ L then the measurement outputs "ACCEPT" with probability s calc ≤ 1 3 . The adaptive measurement supplies the measurements required for each vertex via angles θ v . It also supplies the functions required for the adaptation.
The interactive proof is given by the following procedure.
(b) Accept if the test accepts

Now we calculate the optimal value of q.
Lemma 8. Let L be a language and x in input. Suppose we are given an adaptive measurement on a triangular cluster state on n vertices which implements a measurement-based computation which decides whether x ∈ L with error at most 1 3 (i.e. c calc ≥ 2 3 and s calc ≤ 1 6 ). Let 0 < δ < 1 3 be given and set
• If x ∈ L then for honest provers procedure 3 accepts with probability at least c ip
• If x / ∈ L then for any set of provers procedure 3 accepts with probability at most s ip where c ip − s ip ≥ δ 8 10 19.2 n 11 (122)
Proof. Let c test be the probability of honest provers passing the test, and let s test be the probability of dishonest provers passing the test, given in corollary 3. Here, by dishonest we mean that the probability of a particular outcome of an adaptive measurement made using the provers differs from the honest case by more than the given δ.
Then we have two cases:
• The input is in the language: then we only care about the honest case, in which the probability of accepting is c ip ≥ qc calc + (1 − q)c test .
• The input is not in the language: then there are two cases:
-The provers pass the test with probability at least s test . Then by corollary 3 the probability of accepting on the calculation is at most s calc +δ and the probability of accepting on the test is at most c test for an overall probability of at most q(s calc + δ) + (1 − q)c test .
-The provers pass the test with probability less than s test . Then the probability of accepting on the calculation could be as high as 1, since we gain no information from the test. The overall probability of accepting is then less than q + (1 − q)s test .
The two different cases in the x / ∈ L case give two different gaps which are, in the first case
and in the second case
The overall gap is the minimum of these two. We wish to find q which gives maximizes the minimum. The two equations are just lines in q which cross each other. At the point where they are equal we find the maximum overall gap. The crossing point is easily found to be at
which gives a gap of
On the first line, we see that the denominator can be no larger than 2, and the first factor in the numerator is at least 1 6 (when δ = 1 6 and c calc − s calc = 1 3 ). So we can lower bound the gap by 1 12 (c test −s test ), which is estimated in 3. We are now in a position to prove our main claim. This is obtained by applying a standard gap amplification procedure. 3. Otherwise reject.
Proof of Theorem 1. Let L ∈ BQP be given along with input x. Theorem 2 tells us that we can find an adaptive measurement on a triangular cluster state on n = poly(|x|) vertices whose outcome tells us whether x ∈ L with error less than 1 3 . From Lemma 8 we have an interactive proof such that if x ∈ L then we accept with probability at least c ip for honest provers, and if x / ∈ L we accept with probability at most s ip . Now we amplify using procedure 4. Provided that we use fresh randomness on each run of the interactive proof, the N trials are all independent, although not necessarily identically distributed.
Let us first consider the case x ∈ L. Then we are interested in the case of honest provers, in which case we have N independent and identical Bernoulli trials with some probability of accepting p ≥ c ip . Using Hoeffding's inequality, the probability that we mistakenly reject is bounded by
Setting this equal to 1 3 we solve for N to find the minimum number of trials to achieve our desired error rate.
Subbing in for c ip − s ip as estimated in Lemma 8 we obtain N ≥ 10 38.7 n 22 δ 16 .
The same number of repetitions also suffices to bound the probability of accepting when x / ∈ L to below 1 3 . The analysis is similar, however if the provers are not honest they may vary their behaviour on each trial, so the trials are not necessarily identically distributed. However, since the probability p of accepting satisfies p ≤ s ip for every trial we can still use Hoeffding's inequality.
Note that there is ambiguity in procedure 4. In particular, it does not mention whether the repetition of procedure 3 should be done serially or in parallel. In fact this does not matter. We can add N sets of n provers and query each prover once, or use one set of n provers and query each one N times. Either way the fact that we use fresh randomness keeps each trial independent of other trials. If x / ∈ L then there are no provers, whether entangled with other provers in other trials, retaining memory of past trials, or otherwise, that will force the verifier to accept with probability more than s ip . Hence we can specify that the repetition is accomplished in parallel using nN provers, each of which, in the honest case, performs a single measurement.

Future work

Our error bounds are clearly suboptimal. In many places we have made only loose estimates which suffice for our purposes of establishing a polynomial bound, but could be made more robust. Hence one avenue of future improvement is to tighten these bounds.
Currently our construction uses many simple provers, providing a nice complement to Reichardt et al.'s result using a constant number provers. Much of our result could easily be adapted to the case of two provers. The most difficult part is the graph-state test. Likely it is not possible to prove a self-testing theorem for two provers if there are any odd cycles in the graph since it would be necessary at some point to test the entanglement across an edge with both vertices held by a single prover. However, bipartite graph states could yet be self-tested with two provers. helpful discussions. This work is funded by the Centre for Quantum Technologies, which is funded by the Singapore Ministry of Education and the Singapore National Research Foundation, and by the University of Otago.
The first inequality is a straightforward applications of the definition of ||·||. The second inequality is an application of the first, along with the triangle inequality. The last inequality is an application of the inequality ||O|ψ || ≤ ||O|| ∞ |||ψ || 2 where we use the operator O = φ|M.
Lemma 10. Let t be an n-bit string. Then s∈{0,1} n (−1) s·t = 2 n δ t .
If t = 0 then the summand is always 1. If t = 0 then half the strings s have inner product 0 with t and the other half have inner product 1, so we get a sum with half the summands 1 and the other half -1.
Lemma 11. Let u ∈ {0, 1} n be given and let A be the adjacency matrix for a graph G = (V, E). For the first one, the average inner product of a vector with u is half the number of 1's in u. The second computes this for an average u, which has n/2 1's. For the last one, t · At counts the number of edges in the induced subgraph on S t = {v ∈ V |t v = 1}. Consider an edge (u, v). Then (u, v) appears in the induced subgraph on S t whenever both ends are in S t , i.e. when t u = t v = 1. This happens for a quarter of all bit strings t. Hence each edge is counted 2 n−2 times for a total of 2 n−2 |E|.
This is a standard result in quantum computing, and can be shown using induction on n.
B Local complementation and self-testing stabilizer states Local Complementation. Let G be a graph. We may form a new graph G ′ by local complementation on a vertex v ∈ V . This operation complements all the edges in the neighbourhood of v, meaning that if a, b ∈ V are neighbours of v and (a, b) ∈ E then (a, b) is removed in G ′ and, conversely, if (a, b) / ∈ E then (a, b) is added in G ′ .
Local complementation is relevant to graph states because |G and |G ′ will be related by local Clifford operations, which simply relabel Pauli measurements and outcomes. The standard stabilizer generators for |G ′ are found from those of |G by replacing S u with S u S v for each neighbour u of v, and exchanging Z v with Y v , and X u with Y u .
Self-testing stabilizer states. First, note that an arbitrary stabilizer state is equivalent to a graph state under local Clifford operations {{not_in_s2orc}}. The local Clifford operations just relabel the Pauli operators (up to ±1), so the problem of testing stabilizer states reduces to that of testing graph states.
To self-test an arbitrary graph we first divide it into connected components. The graph state will a product state where the overall graph state is the product of the graph states on the connected components. We may thus test connected components individually. If a component has only one vertex then the test is trivial. If it has two vertices then the graph state on that component is an EPR pair (up to local unitaries), which can be tested using the Mayers-Yao test {{14069874}} or the CHSH test {{18467053}}{{118535156}}. Now we consider a connected component with three or more vertices. We need to show that equation (23) in Lemma 3 holds for each vertex, i.e. the X ′ v and Z ′ v operators approximately anti-commute on the state. It is shown in {{34099972}} (Lemma 2) that if equation (23) holds on vertex v then it also holds (with a larger bound) on any neighbour u of v. Hence as long as (23) holds for at least one vertex in a connected component, then it also holds for all other vertices in the component by inducting along paths.
Let us return to our component with three or more vertices. If it contains a triangle then we test using Lemma 3. If not, then let u, v ∈ V be two vertices in the component that are not adjacent. Since they are in the same component, there is a shortest path between them of length at least 2. Look at the first three vertices in this path. The first and third are not adjacent, otherwise the path would be shorter. Hence we have an induced path of length 2. We then locally complement on the middle vertex, obtaining a triangle. The corresponding graph state is equivalent to the original graph state under local Clifford operations, which can be absorbed into the definition of the local isometry Φ. Now we have a graph state with a triangle and we can apply Lemma 3 and {{34099972}} (Lemma 2) to obtain the anti-commuting relation for all vertices.
Having tested all components and obtained local isometries Φ j for each component j, we simply form Φ = Φ 1 ⊗ · · · ⊗ Φ k and apply triangle equalities to obtain the final isometry and bound.




CITED_PAPERS:


16531904:Quantum cryptography with imperfect apparatus


Introduction

In 1984, Bennett and Brassard [7] proposed a revolutionary concept that key distribution may be accomplished through public communications in quantum channels. Hopefully, the privacy of the resulted key is to be guaranteed by quantum physical laws alone, quite independent of how much computational resource is available to the adversary. The primary quantum phase of the proposed protocol is a sequence of single photons produced by Alice (the sender) and detected by Bob (the receiver).
The security proof of the BB84-protocol (or its many variants) for adversaries with unrestricted power is a difficult mathematical problem, and has only been achieved with any generality in the last few years. In brief, the BB84-protocol is secure even with channel noise and possible detector faults for Bob, provided that the apparatus used by Alice to produce the photons is perfect. The purpose of this paper is to remove this last assumption, by proposing and giving a concrete design for a new concept, selfchecking source, which requires the manufacturer of the photon source to provide certain tests; these tests are designed such that, if passed, the source is guaranteed to be adequate for the security of the BB84-protocol, even though the testing devices may not be built to the original specification. A self-checking source must receive inputs from multiple locations (two in our case) and returns classical outcomes at these locations. The test needs only to consider the classical inputs and the classical outcomes.
It is well known that there are clever ways to construct imperfect sources for the coding used in the BB84-protocol that behave quite normal on the surface, but seriously compromise the security. In other words, the BB84 coding together with the standard test executed in the BB84-protcol are problematic because the external data can be reproduced by quantum apparatus which are not secure at all. We propose a different source that is self-checking and yet can be used to generate the BB84 coding. Our result means that one does not have to perform an infinite number of ways to check all possible devious constructions. In some ways our test can be regarded as simple self-testing quantum programs. Our result requires that, when the inputs to the source are fixed, the distribution of probability for the classical outcomes is also fixed.
Our result is that, if these distributions of probability (associated with the different inputs) are exactly as in the specification for our self-checking source, the state transmitted is a direct sum of states that are individually normally emitted by a perfect source. In practice, we cannot expect these probabilities to be exactly as in the specification for the selfchecking source. However, one can test that they are not too far away from this specification. Furthermore, one should expect that the closer to their specified values these probabilities will be, the closer to the direct sum described above the source will be. This is usually sufficient to prove security.
In Section 2, we show how the main mathematical question arises from the security requirement from the BB84protocol. In Section 3, the precise question is formulated, and the main theorem stated. The proof of the main theorem is given in Section 4.

Preliminaries

Ideally, the objective of key distribution is to allow two participants, typically called Alice and Bob, who initially share no information, to share a secret random key (a string of bits) at the end. A third party, usually called Eve, should not be able to obtain any information about the key. In reality, this ideal objective cannot be realized, especially if we give unlimited power to the cheater, but a quantum protocol can achieve something close to it. See [8] (and more recently [28]) for a detailed specification of the quantum key distribution task. One of the greatest challenges in quantum cryptography is to prove that a quantum protocol accomplishes the specified task. One can experimentally try different kinds of attacks, but one can never know in which way the quantum apparatus can be defective. In any case, such experiments are almost never done in practice because it is not the way to establish the security of quantum key distribution. The correct way is a properly designed protocol together with a security proof.
Recently, there has been a growing interest in practical quantum cryptography and systems have been implemented [1,2,3,4,5,6]. However, proving the security of quantum key distribution against all attacks turned out to be a serious challenge. During many years, many researchers directly or indirectly worked on this problem [7,8,9,10,11,12,13,14,15,16,17,18,19]. Using novel techniques [20,21], a proof of security against all attacks for the quantum key distribution protocol of Bennett and Brassard was obtained in 1996 [22]. Related results were subsequently obtained [23,24,25,26], but as yet [22] is the only known proof of security against all attacks. A more recent version of the proof with extension to the result is proposed in [28]. Also, the basic ideas of [9,10,17] might lead to a complete solution if we accept fault tolerant computation (for example, see [27]), but this is not possible with current technology.
In the quantum transmission, Alice sends n photons to Bob prepared individually in one of the four BB84 states uniformly picked at random. The BB84 states denoted b(0, 2), b(1, 2), b(0, 3) and b(1, 3) correspond to a photon polarized at 0, 90, 45 and −45 degrees respectively (see figure 1). (We reserve the states b(0, 1) and b(1, 1) for further use: we will have to add two other states in our analysis.) Bob measures each photon using either the rectilinear ba- The basic idea of the protocol is the following. Both, Eve and Bob, do not know Alice's bases until after the quantum transmission. Eve cannot obtain information without creating a disturbance which can be detected. Bob also disturbs the state when he uses the wrong basis, but this is not a problem. After the quantum transmission, Alice and Bob announce their bases. Alice and Bob share a bit when their bases are identical, so they know which bits they share. The key point is that it's too late for Eve because the photons are on Bob's side. However, the security of the protocol relies on the fact that the source behaves as specified, and this is the main subject of this paper.
Informally, the source used in the original BB84protocol [7] can be described as a blackbox with two buttons on it: base2-button and base3-button. When Alice pushes the base2-button, the output is either (0, b(0, 2)) or (1, b(1, 2)), where b(0, 2) and b(1, 2) form an orthonormal basis of a two-dimensional system H B , with each possibility occurring with probability 1/2. After the base αbutton is pushed, of the output (x, b(x, α)), only the vector b(x, α) goes out to Bob; bit x is only visible to Alice. Similarly, if Alice pushes the base3-button, the output is either
The suggested way in [7,8] to achieve the above is to have the blackbox generates a fixed state, say b(0, 2), then the bit x ∈ {0, 1} is uniformly chosen at random and this state is rotated of an appropriate angle to create the desired state b(x, α) (assuming that the base α-button is pressed). The security proof of the protocol extends to sources beyond mentioned above. To obtain our self-testing source, we need to consider a different type of sources. A conjugate coding source S = (H A ⊗ H B , Ψ, M 2 , M 3 ) consists of a pure state Ψ in a Hilbert space H A ⊗ H B , and two measurements (each binary-valued) M 2 , M 3 defined on H A ⊗H B but operating only on coordinates in H A . Pushing base2-button, base3-button performs respectively measurement M 2 , M 3 . (We have restricted the form of the initial state to be a pure state |Ψ instead of a general mixed state. This is without loss of generality for our result, as we will see.)
Let P + α , P − α , where α ∈ {2, 3}, denote the projection operators to the subspaces corresponding to the outcomes 0, 1 for measurement M α . (We sometimes use the notation P ± α to denote the measurement M α itself.) After performing the measurement, only the coordinates in H B are made available for transmission. Thus, if button α is pushed with outcome 0, the density operator in the transmitted beam is
. For convenience, we sometimes identify + with 0, and − with 1. Thus, if button α is pushed with outcome x, the density operator is tr A (P x α |Ψ Ψ|P x α ). The security proof of the protocol is valid if the source satisfies, for x ∈ {0, 1}, the conditions 3)) are orthonormal bases that satisfy equation (1). It is well known (and easy to see) that the following source satisfies the above condition. Let H A , H B each be a two-dimensional Hilbert space.
Let (a(0, 2), a(1, 2)), (a(0, 3), a(1, 3)) be two pairs of orthonormal bases of H A related by equation (1); similarly let (b(0, 2), b(1, 2)), (b(0, 3), b(1, 3)) be two pairs of orthonormal bases related by equation (1) 3)) respectively. Clearly, (2) is true. We call this source the perfect system.
More generally, the security proof extends to systems that behave like a mixture of orthogonal ideal systems. A source is an extended perfect system if there exist in H B orthogonal two dimensional subspaces H i (i ∈ I, some index set), with b i (x, 2), b i (x, 3) denoting states in H i that respect the same ortogonality condition as the above states b(x, 2), b(x, 3) in H B and equation (1), such that for some probability distribution p i on i ∈ I,
Now comes the question. If a manufacturer hands over a source and claims that it is a perfect system, how can we check this claims, or at least, makes sure that it is an extended perfect system?
If the source is a perfect system, let N 2 , N 3 be the measurements operating on H B in exactly the same way as
) be the projection operators to subspaces by N α with outcome 0, 1; (1, 3) , respectively. Now observe that the following are true for
We can ask the manufacturer to provide in addition two measuring devices outside the blackbox corresponding to N 2 , N 3 . A test can be executed to verify that these equations are satisfied (see the related discussion in the Introduction). Furthermore, as a matter of physical implementation, to make sure that M ′ s and N ′ s operate on H A , H B respectively, we can further demand that the buttons are replaced by two measuring devices outside the blackbox. Is that sufficient to guarantee that we have at least an extended perfect system?
Unfortunately, the answer is NO. It is not hard to construct examples where (4) is satisfied, but it is not an extended ideal system (and in fact, security is gravely compromised).
However, as we will see, if we add one more measurement appropriately on each side, and perform the corresponding checks, then it gurantees to be an extended perfect system. That will be the main result of this paper.

Main Theorem

is called an ideal source if the following are valid: each of H A , H B is a 2-dimensional Hilbert space with (a(0, 2), a(1, 2)), (a(0, 3), a(1, 3)) being a pair of orthonormal basis of H A satisfing equation (1), and (b(0, 2), b(1, 2)), (b (0, 3), b(1, 3)) being a pair of orthonormal basis of H B satisfying equation (1); Ψ is the Bell state (a(0, α)b(0, α)+a(1, α)b(1, α))/ √ 2; P + 2 , P − 2 are the projection operators on the states a(0, 2), a(1, 2) respectively; P + 3 , P − 3 are the projection operators on the states a(0, 3), a(1, 3) respectively. To describe P ± 1 , let a(x, 1) (x ∈ {0, 1}) be the state a(x, 2) + a(x, 3) after being normalized to unit length. The states a(x, 1) and b(x, 1) have a particular status in our proof, and we alternatively denote a(x, 1) = |x and b(x, 1) = |x ′ . Then P + 1 , P − 1 are respectively the projection operators on the states |0 , |1 . As usual, we consider P x α and P x α ⊗ I as two alternative notations for one and the same projection operators on H A ⊗ H B . Clearly, P ± 1 , P ± 2 , P ± 3 are the projection operators on H A ⊗ H B corresponding to measuring H A with respect to three bases of H A (the bases for P ± 2 , P ± 3 at an angle of −π/8, +π/8 with repect to the basis for P ± 1 ). The projection operators R ± 1 , R ± 2 , R ± 3 operate on coordinates in H B , and are similarly defined as the P ′ s. Let
These numbers can be easily computed. For example, p 1,2 (0, 0) = (cos(π/8)) 2 /2 and p 1,2 (0, 1) = (sin(π/8)) 2 /2.
consists of an initial state |Ψ ∈ H A ⊗ H B , three measurements P ± 1 , P ± 2 , P ± 3 acting on coordinates in H A , and three measurements R ± 1 , R ± 2 , R ± 3 acting on coordinates in H B , such that the following conditions are satisfied:
We will see that a self-checking source gives rise to an extended ideal system.
An extended ideal source
is an orthogonal sum of ideal sources in a similar sense as an extended perfect system in relation to perfect systems. That is, if there is an index set I, orthogonal two dimensional subspaces K i ⊆ H A with a i (x) (or alternatively a i (x, 1)) denoting the state |x in K i , orthogonal two dimensional subspaces H i ⊆ H B with b i (x, α) (or alternatively b i (x, 1)) denoting the state |x ′ in H i , such that for some (possibly complex) numbers α i on i ∈ I with i∈I |α| 2 = 1,
Furthermore, for each i, for every projection P ∈ {P ± 1 , P ± 2 , P ± 3 }, P acts exactly on K i like the corresponding projection on H A in the ideal source case. That is, if P |x = λ 0 |0 + λ 1 |1 in the ideal case, we have that P a i (x) = λ 0 a i (0) + λ 1 a i (1). The following fact is easy to verify.

Fact 1 Any extended ideal source is a self-checking source.

Also, it is clear that from any self-checking source, by omitting the measurements P ± 1 , R ± 1 , one obtains a conjugate coding source.

Fact 2

The conjugate coding source obtained from an extended ideal source must be an extended perfect system.
The converse of fact 1 is our main theorem.
Main Theorem Any self-checking source is an extended ideal source.
It follows from the Main Theorem and Fact 2 that a selfchecking source provides an adequate source for the BB84 quantum key distribution protocol [7,8].
We remark that in our definition of self-checking source, the restriction of the initial state to a pure state |Ψ instead of a mixed state ρ is not a real restriction. Given a source with a mixed state ρ satisfying equation (6), we can construct one with a pure state |Ψ (by enlarging appropriately H A ) satisfying (6). We can apply the Main Theorem to this new source, and conclude that it also gives rise to an adequate source for the BB84-protocol.
It is well known, from discussions about EPR Experiments (see e.g. [29]), that quantities such as ||R x α P y β |Ψ || 2 exhibit behavior characteristic of quantum systems that cannot be explained by classical theories. One may view our main result as stating that such constraints are sometimes strong enough to yield precise structural information about the given quantum system; in this case it has to be an orthogonal sum of EPR pairs

Proof of Main Theorem

We give in this Section a sketch of the main steps in the proof. Let S = (H A ⊗ H B , |Ψ , P ± 1 , P ± 2 , P ± 3 , R ± 1 , R ± 2 , R ± 3 ) be a self-checking source. We show that it must be an extended ideal source.
In Section 4.1, we derive some structural properties of the projection operators as imposed by the self-checking conditions, but without considering in details the constraints due to the tensor product nature of the state space. In Sections 4.2 and 4.3, the state is decomposed explicitly in terms of tensor products, and the properties derived in Section 4.1 are used to show that this decomposition satisfies the conditions stated in the Main Theorem.

Properties of Projections

In this subsection, we present some properties of the projected states (such as P + 1 Ψ, P + 1 R − 2 Ψ) as consequences of the constraints put on self-checking sources. The proofs of these lemmas are somewhat lengthy, and will be left to the complete paper. Lemma 1 For every α ∈ {1, 2, 3} and x ∈ {+, −}, we have P x α Ψ = R x α Ψ.
Let v i ∈ V, w i ∈ W for 1 ≤ i ≤ m, where V, W are two Hilbert spaces. We say that (v 1 , v 2 , · · · , v m ) is isormorphic to (w 1 , w 2 , · · · , w m ) if there is an inner-product-preserving linear mapping f : V → W such that w i = f (v i ) for all i.
Let θ = π/8, and u 1 , u 2 , · · · , u 5 be elements of C 2 defined by (1, 0), u 2 = (cos 2 θ, sin θ cos θ), u 3 = (sin 2 θ, − sin θ cos θ), u 4 = (cos 2 θ, − sin θ cos θ), u 5 = (sin 2 θ, sin θ cos θ).
.
Since there is a symmetry between the projection operators P and R, the following is clearly true.

The Decomposition

We now prove that the state Ψ ∈ H A ⊗ H B can be decomposed into the direct sum of EPR pairs. We begin with a decomposition of P + 1 Ψ, which is equal to R + 1 Ψ by Lemma 1. Lemma 6 One can write
where I is an index set, α i are complex numbers, and a i (0) ∈ H A (i ∈ I), b i (0) ∈ H B (i ∈ I) are two respectively orthonormal sets of eigenvectors of the operators P + 1 (acting on H A ) and R + 1 (acting on H B ). Proof The lemma is proved with the help of Schmidt decomposition theorem [30] [31]. We omit the details here.
and that K i , H i have all the properties required to satisfy the Main Theorem.
In the remainder of this subsection, we use Lemmas 2-5 to show that each H i (K i ) behaves correctly under the projection operators R x γ (P x γ ). In the next subsection, we complete the proof by showing that all H i (K i ) are orthogonal to each other.
By Lemma 2, (u 1 , u 2 , · · · , u 5 ) is isomorphic to
In particular, this implies that any linear relation j λ j u j = 0 must also be satisfied if u j are replaced by the appropriate projected states. Now
This means that, for each i ∈ I, any linear relation j λ j u j = 0 must also be satisfied if we make the following substitutions:

Lemma 7

For each i ∈ I, (u 1 , u 2 , · · · , u 5 ) is isomorphic to
Proof Use the preceding observation and the orthogonality between R + 3 b i (0) and R − 3 b i (0), and the orthogonality between R + 2 b i (0) and R − 2 b i (0)). We omit the details here. ✷ Lemma 7, it is easy to see that b i (1) is a unit vector perpendicular to b i (0). In fact, b i (1) is mapped to the vector (0, 1) under the isomorphism in Lemma 7. ¿From Lemma 7, for the purpose of vectors in the space H i , the projection operators R + 3 , R − 3 correspond to choosing the coordinate system obtained from the system (b i (0), b i (1)) rotated by the angle θ; similarly, R + 2 , R − 2 correspond to choosing a coordinate system obtained from the system (b i (0), b i (1)) rotated by the angle −θ. It remains to show that R + 1 , R − 1 correspond to the coordinate system
. To do that, we use Lemma 3. Observe that
. This completes the proof that the projection operators R x γ behave as required on the subspace H i . As stated explicitly in Lemma 5, we can obtain the symmetric statement that the the projection operators P x γ behave as required on the subspace K i . Now that we have determined the behavior of the projection operators on K i , H i , we can in principle calculate any polynomial of the projection operators on the state P + 1 Ψ. By Lemma 4, P − 1 Ψ can be written as
This gives P − 1 Ψ = 2β 2 i∈I α i (P + 2 − cos 2 θ)a i (0) ⊗ (R + 2 − R + 3 )b i (0).
After applying the rules and symplifying, we obtain P − 1 Ψ = i∈I α i a i (1) ⊗ b i (1).
As Ψ = P + 1 Ψ + P − 1 Ψ, this proves (1)).

Completing the Proof

It remains to show that all H i are orthogonal to each other. (A symmetric argument then shows that all K i are also orthogonal to each other.)
Let i = j ∈ I. Assume that H i is not orthogonal to H j . We derive a contradiction. By definition, H i is spanned by b i (0), b i (1), and H j is spanned by b j (0), b j (1). Clearly, b i (1) and b j (1) are not orthogonal to each other, as all the other pairs (b i (x), b j (y)) are orthogonal. where s = 0. From our knowledge about the behavior of R 3 , we infer that R + 3 b j (0) = (cos θ)w where w = cos θb j (0) + sin θb j (1) = (0, s sin θ, cos θ, t sin θ). Similary, R − 3 b i (0) = (sin θ)w ′ where w ′ = − sin θb i (0) + cos θb i (1) = (− sin θ, cos θ, 0, 0). As the inner product of w and w ′ is s sin θ cos θ which is non-zero, we conclude that R + 3 b j (0) and R − 3 b i (0) are not orthogonal. This contradicts the fact that R + 3 , R − 3 are projection operators to orthogonal subspaces. This completes the proof.

Concluding Remarks

The security problem for imperfect source is a difficult one to deal with. The present paper is a step in only one possible direction. We have also limited ourselves to the simplist case when the correlation probabilities p α,β (x, y) are assumed to be measurable precisely. We leave open as future research topics for extensions to more general models.

Figure 1 .

1The BB84 states sis {b(0, 2), b(1, 2)} or the diagonal basis {b(0, 3), b(1, 3)} uniformly chosen at random.

.

for H B . Let Ψ be the Bell state (|a(0, 2) |b(0, 2) + |a(1, 2) |b(1, Let M 2 , M 3 be two measurements on H A ⊗H B that operate only on the coordinates in H A . The measurement M 2 consists of the two orthogonal subspaces |a(0, 2) ⊗ H B , |a(1, 2) ⊗ H B . The measurement M 3 consists of the two orthogonal subspaces |a(0, 3) ⊗ H B , |a(1, 3) ⊗ H B . If we restrict them to H A only, the measurement M 2 , M 3 are the measurements in the bases (a(0, 2), a(1, 2)) and (a(0, 3), a(1,

Lemma 5

5Lemmas 2-4 remain valid if the projection operators P and R are exchanged.
be the subspace spanned by a i (0) and a i (1); Let H i ⊆ H B be the subspace spanned by b i (0) and b i (1). The plan is to show that
* This research was supported in part by DIMACS, and by DARPA/ITO and the National Science Foundation under Grant CCR-9627819.
Enhanced single photon fringe visibility in a 10 km-long prototype quantum cryptography channel. P D Townsend, J G Rarity, P R Tapster, Electronics Letters. 2914P.D. Townsend, J.G. Rarity and P.R. Tapster, Enhanced single photon fringe visibility in a 10 km-long prototype quantum cryptography channel, Electronics Letters, vol. 29, no. 14, 8 July 1993, pp. 1291 -1293.
Experimental demonstration of quantum cryptography using polarized photons in optical fiber over more than 1 km. A Muller, J Breguet, N Gisin, Europhysics Letters. 236A. Muller, J. Breguet and N. Gisin, "Experimental demon- stration of quantum cryptography using polarized photons in optical fiber over more than 1 km", Europhysics Letters, vol. 23, no. 6, 20 August 1993, pp. 383 -388.
Quantum cryptography using optical fibers. J D Franson, H Ilves, Appl. Optics. 33Franson, J. D., Ilves, H., "Quantum cryptography using op- tical fibers", Appl. Optics 33 (1994), 2949-2954.
Quantum cryptography over underground optical fibers. R J Hughes, G G Luther, G L Morgan, C G Peterson, C Simmons, Advances in Cryptology: Proceeding of CRYPTO'96. R. J. Hughes, G. G. Luther, G. L. Morgan, C. G. Peter- son and C. Simmons "Quantum cryptography over under- ground optical fibers", Advances in Cryptology: Proceeding of CRYPTO'96.
Quantum cryptography in free space. B C Jacobs, J D Franson, Optics Letters. 21B.C. Jacobs and J.D. Franson, "Quantum cryptography in free space", Optics Letters, vol 21, no 22, November 15, 1996.
Free-space quantum-key distribution. W T Buttler, R J Hughes, P G Kwiat, G G Luther, G L Morgan, J E Nordholt, C G Peterson, C M Simmons, Physical Review A. 574W. T. Buttler, R. J. Hughes, P. G. Kwiat, G. G. Luther, G. L. Morgan, J. E. Nordholt, C. G. Peterson, and C. M. Simmons, "Free-space quantum-key distribution", Tentatively sched- uled for 1 April 1998, Physical Review A, vol 57, no 4.
Quantum Cryptography: Public key distribution and coin tossing. C H Bennett, G Brassard, Proc. of IEEE International Conference on Computers, Systems, and Signal Processing. of IEEE International Conference on Computers, Systems, and Signal essingBanglore, IndiaC.H. Bennett, G. Brassard, "Quantum Cryptography: Public key distribution and coin tossing", Proc. of IEEE Interna- tional Conference on Computers, Systems, and Signal Pro- cessing, Banglore, India, December 1984, pp. 175 -179.
Experimental quantum cryptography. C H Bennett, F Bessette, G Brassard, L Salvail, J Smolin, Journal of Cryptology. 51C.H. Bennett, F. Bessette, G. Brassard, L. Salvail and J. Smolin, "Experimental quantum cryptography", Journal of Cryptology, vol. 5, no 1, 1992, pp. 3 -28.
Quantum cryptography based on Bell's theorem. A K Ekert, Physical Review Letters. 676A.K. Ekert, Quantum cryptography based on Bell's theo- rem, Physical Review Letters, vol. 67, no. 6, 5 August 1991, pp. 661 -663.
Purification of Noisy Entanglement and Faithful Teleportation via Noisy Channels. C H Bennett, G Brassard, S Popescu, B Schumacher, J Smolin, W K Wootters, Physical Review Letters. 76722C.H. Bennett, G. Brassard, S. Popescu, B. Schumacher, J. Smolin and W.K. Wootters, "Purification of Noisy En- tanglement and Faithful Teleportation via Noisy Channels", Physical Review Letters, vol. 76, pp. 722 (1996).
Quantum privacy amplification and the security of quantum cryptography over noisy channels. D Deutsch, A Ekert, R Jozsa, C Macchiavello, S Popescu, A Sanpera, Phys. Rev. Lett. 77Deutsch, D., Ekert, A., Jozsa, R., Macchiavello, C., Popescu, S., Sanpera, A., "Quantum privacy amplification and the se- curity of quantum cryptography over noisy channels", Phys. Rev. Lett. 77 (1996), 2818-2821.
Quantum cryptography using any two nonorthogonal states. C H Bennett, Physical Review Letters. 6821C.H. Bennett, "Quantum cryptography using any two nonorthogonal states", Physical Review Letters, vol. 68, no. 21, 25 May 1992, pp. 3121 -2124.
Quantum Oblivious Transfer is Secure Against All Individual Measurements. D Mayers, L Salvail, Proceedings of the workshop on Physics and Computation, PhysComp '94. the workshop on Physics and Computation, PhysComp '94DallasD. Mayers and L. Salvail, Quantum Oblivious Transfer is Secure Against All Individual Measurements, Proceedings of the workshop on Physics and Computation, PhysComp '94, Dallas, Nov 1994, pp. 69 -77.
Information gain in quantum eavesdropping. B Huttner, A K Ekert, Journal of Modern Optics. 41B. Huttner and A.K. Ekert, "Information gain in quantum eavesdropping", Journal of Modern Optics, vol 41, no 12, December 1994, pp. 2455 -2466.
Eavesdropping on quantum cryptosystems. A K Ekert, B Huttner, G M Palma, A Peres, Physical Review A. 50A.K. Ekert, B. Huttner, G.M. Palma and A. Peres, "Eaves- dropping on quantum cryptosystems", Physical Review A, vol 50, 1994, pp. 1047 -1056.
Security against eavesdropping in quantum cryptography. N Lütkenhaus, S M Barnett, Proceedings of an International Workshop on Quantum Communication, Computing, and Measurement. an International Workshop on Quantum Communication, Computing, and MeasurementShizuoka, Japan; New YorkPlenum PressN. Lütkenhaus and S.M. Barnett, "Security against eavesdropping in quantum cryptography", Proceedings of an International Workshop on Quantum Communication, Computing, and Measurement, September 25-30, 1996, Shizuoka, Japan, Plenum Press, New York (1997).
. C H Bennett, G Brassard, S Popescu, B Schumacher, J Smolin, W K Wootters, Physical Review Letters. 76C.H. Bennett, G. Brassard, S. Popescu, B. Schumacher, J. Smolin et W.K. Wootters, Physical Review Letters, vol. 76, 1996, pp. 722 -725.
. D Deutsch, A K Ekert, R Jozsa, C Macchiavello, S Popescu, A Sanpera, Physical Review Letters. 77D. Deutsch, A.K. Ekert, R. Jozsa, C. Macchiavello, S. Popescu and A. Sanpera, Physical Review Letters, vol. 77, 1996, pp. 2818 -2821,.
Parity bit in quantum cryptography. C H Bennett, T Mor, J A Smolin, Phys. Rev. A. 54Bennett, C. H., Mor, T., Smolin, J. A., "Parity bit in quantum cryptography", Phys. Rev. A 54 (1996), 2675-2684.
Security of quantum protocols against coherent measurements. A C C Yao, Proceedings of 1995 ACM Sym. 1995 ACM SymA. C. C. Yao, "Security of quantum protocols against co- herent measurements", Proceedings of 1995 ACM Sym. on Theo. Comp. (1995), pp. 67 -75.
On the security of the Quantum Oblivious Transfer and Key Distribution protocols. D Mayers, Advances in Cryptology: Proceeding of CRYPTO'95. BerlinSpringer -Verlag963D. Mayers, On the security of the Quantum Oblivious Trans- fer and Key Distribution protocols, Advances in Cryptol- ogy: Proceeding of CRYPTO'95, Lecture Notes in Com- puter Science, vol. 963, Springer -Verlag, Berlin, 1995, pp. 124 -135.
Quantum key distribution and string oblivious transfer in noisy channel. D Mayers, Advances in Cryptology: Proceedings of Crypto'96. Springer-Verlag1109D. Mayers, "Quantum key distribution and string oblivious transfer in noisy channel", Advances in Cryptology: Pro- ceedings of Crypto'96, Lecture Notes in Comp. Sci., vol 1109, (Springer-Verlag, 1996), pp. 343 -357.
Bounds on information and the security of quantum cryptography. E Biham, T Mor, Phys. Rev. Lett. 79Biham, E., Mor, T., "Bounds on information and the security of quantum cryptography", Phys. Rev. Lett. 79 (1997), 4034- 4037.
Security of quantum key distribution against all collective attacks. E Biham, M Boyer, G Brassard, J Van De Graaf, T Mor, quant-ph/9801022Los AlamosBiham, E., Boyer, M., Brassard, G., van de Graaf, J., Mor, T., "Security of quantum key distribution against all collective attacks", Los Alamos preprint archive quant-ph/9801022 (1998).
Optimal eavesdropping in quantum cryptography. I. Information bound and optimal strategy. C A Fuchs, N Gisin, R B Griffiths, C.-S Niu, A Peres, Phys. Rev. A. 56Fuchs, C. A., Gisin, N., Griffiths, R. B., Niu, C.-S., Peres, A., "Optimal eavesdropping in quantum cryptography. I. Infor- mation bound and optimal strategy", Phys. Rev. A 56 (1997), 1163-1172.
Optimal eavesdropping in quantum cryptography. II. A quantum circuit. R B Griffiths, C.-S Niu, Phys. Rev. A. 56quant-ph/9803006 [abs, src, ps, otherGriffiths, R. B., Niu, C.-S., "Optimal eavesdropping in quan- tum cryptography. II. A quantum circuit", Phys. Rev. A 56 (1997), 1173-1176. quant-ph/9803006 [abs, src, ps, other] :
Security of Quantum Key Distribution" Los Alamos preprint archive quant-ph/9803006. H.-K Lo, H F Chau, H.-K. Lo, H. F. Chau, "Security of Quantum Key Distribu- tion" Los Alamos preprint archive quant-ph/9803006, March 1998.
Unconditional security in quantum cryptography. D Mayers, Los Alamos preprint archive quant-ph/9802025. D. Mayers, "Unconditional security in quantum cryptogra- phy", Los Alamos preprint archive quant-ph/9802025 (1998).
Experiments on Einstein-Podolsky-Rosen-type correlations with pairs of visible photons. A Aspect, P Grangier, Quantum Concepts in Space and Time. R. Penrose and C.J. IshamOxfordClarendon PressA. Aspect and P. Grangier, "Experiments on Einstein- Podolsky-Rosen-type correlations with pairs of visible pho- tons", in Quantum Concepts in Space and Time, edited by R. Penrose and C.J. Isham, Clarendon Press, Oxford, 1986, 1-15.
. E Schmidt, Math. Ann. 63433E. Schmidt, Math. Ann. 63 (1906) 433.
. L P Hughston, Richard Jozsa, William K Wootters, Physics Letters A. 183L. P. Hughston, Richard Jozsa and William K. Wootters, Physics Letters A, vol. 183, pp. 14 -18, 1993.


44939389:Generalized Self-testing and the Security of the 6-State Protocol


Introduction

In [MY04], [MY98], Mayers and Yao introduced the concept of self-testing quantum apparatus with a test for EPR sources and a select set of measurements. In a parallel development, van Dam et al. [vMMS00] introduced the notion of self-testers for quantum circuits in the case where the dimension of the Hilbert space is known. These results were then combined and improved upon by Magniez et al. in [MMMO06], who give a construction for self-testable circuits without knowledge of the dimension of the Hilbert space.
The Mayers-Yao test, and the test of Magniez et al., only allowed for the testing of states and operators that are equivalent to states and operators in a real Hilbert space. McKague et al. [MMG09] showed that in such settings with untrusted apparatus, one cannot experimentally distinguish a quantum system with states and evolution involving complex amplitudes from a special simulation using only real amplitudes. In addition to the implications for self-testing untrusted quantum apparatus, this also resolved an open question posed by Gisin [Gis07] related to the violation of Bell inequalities. It is important to note that the real simulation does not preserve inner product relationships from the system it is simulating. At first glance, this suggests that the well-known 6-state protocol [BBBW84], [Bru98] might not be secure in a setting with untrusted apparatus, since the simulated versions of the six quantum states could be more distinguishable than the proofs of security assume, and an adversary could exploit this additional distinguishability and compromise security.
In fact, it is easy to describe such an insecure implementation of the 6-state protocol with untrusted apparatus, however even an implementation of standard BB84 quantum key establishment with untrusted apparatus is insecure if proper measures are not taken in order to rule out "sidechannel" attacks. We show that with comparable precautions as those proposed by Mayers and Yao the 6-state protocol remains secure. This paper starts by describing a general family of simulations that will reproduce the same statistics as any given "reference" experiment, and are thus experimentally indistinguishable from said experiment. We show how the real Hilbert space simulation given in [MMG09] is equivalent to a special case of this family of simulations. The fact that these simulations work is not very surprising: they are essentially mixtures of the reference experiment, or the complex conjugate of the reference experiment. Thus, we have a more general collection of experiments that are experimentally indistinguishable in a self-testing framework. What is particularly remarkable is that we are able to describe, in section 4.1, a family of self-tests which can only be passed by simulations from the general family we describe (up to equivalence, as defined below). This is summarized in Theorem 2.
The self-tests allow us to put a physical experiment in a general collection of experiments, and we are then able to show that the 6-state protocol is secure for all the experiments within this collection. This shows that it is possible to define a secure 6-state protocol within the self-testing framework.
In section 3, we prepare for the proof of Theorem 2, by discussing the Mayers-Yao self-tested source result given in Theorem 1, a new proof of which is given in appendix C. This new proof is shorter and simpler, and more easily extended to prove our more general result.
Then, in section 4.1, we describe a new self-test for an EPR source and local measurement apparatus that will uniquely characterize the general equivalence class associated with this quantum state and measurement operators.
In section 5, we discuss the cryptographic implications, and why a properly self-tested 6-state protocol is still secure.
Lastly, in section 6, we discuss some open problems and future directions, including the robustness of the generalized self-tests.

Simulations

In this section we extend the work of McKague et al. in [MMG09]. There the authors gave a construction that allowed the outcomes of any experiment (the reference experiment) to be duplicated (simulated) by another experiment (the simulation) which is described entirely using real numbers. That is to say, all the states, measurement operators, unitaries, Kraus operators, and Hamiltonians are given as vectors and matrices over the real numbers. Of particular interest here is the fact that the simulation is, in general, not equivalent to the reference experiment according to definition 1 below.
In this section we give a construction for a wider family of simulations. The different simulations in the family are, in general, not equivalent to either the reference experiment nor each other. We will be most interested in states and measurements, but, as with the real simulation in [MMG09], it is also possible to simulate discrete and continuous time evolution.
The simulations rely on the simple observation that transforming an experiment by complex conjugation does not alter the statistics it generates. We could also take a classical mixture of the reference experiment and its complex conjugation, flipping a coin (or controlling on a qubit) beforehand to decide which one to perform. In the remainder of this section we fill in some details about the simulations defined by these mixtures.

States and measurements

Consider a reference state 3 |ψ measured according to a reference POVM {P k }. We may duplicate the statistics of this experiment using the complex conjugate state |ψ * and POVM {P * k }. In addition, we could do some combination of the two; we may add an additional qubit register which records which of the two experiments to perform: |0 for the reference experiment, and |1 for the complex conjugate. This qubit may be in any state, and not necessarily pure. We then arrive at a new state
with a ≥ 0 and |c| ≤ a(1 − a). The important feature is that when we project onto |0 0| or |1 1| we get either |ψ or |ψ * , respectively. For the measurement, we form the POVM
This POVM measurement is equivalent to measuring the added qubit, collapsing the state into either |ψ or |ψ * and then measuring either {P k } or {P * k } as appropriate; thus the statistics of the experiment are preserved.
Different simulations are arrived at by choosing different values of a and c. If a = 1 and c = 0 then we obtain the reference experiment. For a = 0 and c = 0 we obtain the complex conjugate. Another interesting case is when a = c = 1 2 , in which case we obtain (up to a local change of bases) the real simulation of [MMG09] as shown in appendix B.

Operators

Although it will not be necessary for our discussion, it is possible to simulate a reference experiment which includes evolution, according to a unitary, completely-positive map, or Hamiltonian. The details are discussed in appendix A.

Non-local computations

For multi-party experiments, such as the Mayers-Yao test, we would need the simulation to be performed in a local fashion with the measurements operating on local systems only. As defined above this not the case, but it is easy to modify the operators to make it so. We simply add an extra qubit for each party and record in each qubit whether to perform the reference experiment or the complex conjugate. We arrive at states analogous to that in equation 1, but with |0 and |1 replaced with logical states 0 = |00 . . . 0 , 1 = |11 . . . 1 defined on the extra qubits held by the various parties. Finally, each party conditions their operations on their local copy of the qubit, applying either the reference operation or the complex conjugate.

Mayers-Yao self-test

The goal of the Mayers-Yao test is to compare two experiments. The first experiment is the reference experiment, which is the experiment we wish to implement. It is a blueprint, or gold standard, against which we compare the other experiment, the physical experiment, which is the experiment that is actually performed. Within the physical experiment we consider the entire physical apparatus, including the environment, so that we obtain a pure state on a Hilbert space of unknown dimension (however, we will limit ourselves to finite dimensions.) The reference and physical experiments consist of reference and physical states, operations, and measurements. The two experiments are compared through the statistics that they generate.

Equivalence

The proof considers a particular reference experiment, as described in section 3.2. This experiment is defined on a pair of qubits, so we will limit our discussion to such systems. As well, we consider only pure states -the physical system is unlimited (but finite) in size, so we may include the environment to obtain a pure state. The conclusion of Mayers and Yao is that if the statistics of a physical experiment agree with that of the reference experiment, then the physical experiment is equivalent to the reference experiment, under a particular notion of equivalence.
When defining a notion of equivalence in this setting we must first consider how me might change the reference experiment in a way that preserves the statistics of the outcomes. Any such change is invisible from the perspective of the statistics and hence we cannot rule them out. Here is a list of such changes:
1. Local changes of basis 2. Adding ancillae to physical systems, prepared in any joint state (the measurement does not act on them) 3. Changing the action of the observables outside the support of the state 4. Locally embedding the state and operators in a larger (or smaller) Hilbert space.
In order to accommodate these various changes we define equivalence as follows.
Definition 1. A reference experiment is described by a n-partite state |ψ on Hilbert space X = X 1 ⊗ . . . X n and local measurement observables M m for various m. Further, consider a physical experiment described by a n-partite state |ψ ′ on Hilbert space Y = Y 1 ⊗ · · · ⊗ Y n and local measurement observables M ′ m for various m. We say that the physical experiment is equivalent 4 to the reference experiment (and the physical state and measurement observables are equivalent to the reference state and measurement observables) if there exists a local isometry
The isometry Φ may be constructed by attaching ancillae in some product state |00 . . . 0 X and applying local unitaries to the subsystems. Note that if we make any finite number of changes from the list above then we may construct a suitable local isometry and show that the experiment is equivalent to the reference experiment. Also, any experiment that is equivalent to the reference experiment may be constructed by applying changes from the list above: one simply attaches ancillae in the state |junk and performs a suitable change of basis. The content of the main theorem is that, for a carefully chosen experiment, these are the only changes that preserve the statistics.
Theorem 1 (Mayers and Yao). Suppose a physical experiment reproduces the statistics of the reference experiment described in section 3.2. Then the physical experiment is equivalent to the reference experiment.
A simplified proof for the Mayers-Yao self-test is give in appendix C.
4 Note that this is not an equivalence relation since it is not symmetric.

Mayers-Yao self-test reference experiment

A general schematic for the Mayers-Yao reference experiment is shown in figure 1. A bipartite state |ψ is distributed to a pair of measurement devices. The two measurement devices take classical inputs a and b, which each take one of three values. The devices then output classical bits, x and y.
The reference state is an EPR pair |φ + = 1 √ 2 (|00 + |11 ) and the reference measurement observables are X, Z, X+Z √ 2 for each side of the EPR pair. For brevity we label X+Z √ 2 = D. For the untrusted physical devices this equality is not given, so there the separate label D is required.

Extending the Mayers and Yao self-test

The original Mayers and Yao EPR test utilized only a small set of measurements. Conspicuously missing is anything with complex coefficients. An important consequence of this is that the circuit test developed by Magniez et al. [MMMO06] is not able to test gates with complex coefficients; only gates with real coefficients can be tested. More specifically, real measurements reveal no information about the imaginary component of a density matrix.
In fact the Mayers-Yao self-test cannot be directly extended to include any measurements with complex coefficients. This is a result of the notion of equivalence used. Suppose that we wish to include the Y measurement in the set of reference measurements. The devices could instead implement −Y , the complex conjugate. So long as all complex measurements were complex conjugated it would be impossible to detect this change. Although this does not present an immediate problem -such a transformation is internally consistent and produces the correct outcome statistics -we cannot transform such a circuit back into the reference circuit using unitary transformations.
If this were the whole story we could simply require that the physical circuit be transformable into either the reference circuit or its complex conjugate. However, the real simulation, and now the general family of simulations, are also indistinguishable from the reference circuit and not unitarily transformable into the reference circuit.
We have one encouraging fact: all of the known simulations are equivalent to a simulation from the general family of simulations. We now prove that we can extend the Mayers-Yao test such that these are the only simulations. Hence we may extend our notion of equivalence to include these simulations and obtain a new self-testing theorem.
Theorem 2. Suppose a physical experiment duplicates the statistics generated by the reference experiment described in section 4.1. Then the physical experiment is equivalent to one of the simulations of the reference experiment described in section 2.

Extended Mayers-Yao self-test reference experiment

The extended Mayers-Yao test will consist of three regular Mayers-Yao tests, performed together. Alice and Bob will perform the Mayers-Yao test with measurement settings (labelled with subscript A when used by Alice, and subscript B when used by Bob):
1. X, Z, and D 2. X, Y , and E 3. Y , Z, and F .
In the reference experiment the measurement settings X, Y and Z are realized by the Pauli operators, with Y B = −Y and otherwise
2 on Bob's side. Bob's Y B measurements all carry the −1 phase since measuring the state |φ + with the operator Y ⊗ Y produces −1 instead of 1 as in the Mayers-Yao reference experiment. The reference state is again |φ + .

Proof of Theorem 2

We start by assuming that the states are all pure as in the Mayers-Yao test. Again we may incorporate the purification of a mixed state into either Alice or Bob's state by adding an ancilla.
First we apply the Mayers-Yao result with the measurements X, Z and D. We find a local isometry Φ as in definition 1. We extend Φ by adding an extra qubit for each side initialized in the state |0 . Then Φ takes the X A , Z A , X B and Z B measurements to
where R A and R B are the added qubit registers and S A and S B are the junk registers. Meanwhile the state has the form |φ
We now consider the remaining measurements. The reference experiments for these measurements can be transformed using local unitaries into the usual Mayers-Yao reference experiments. Thus we may apply the result. However, we stop short of using the full result. Within the proof of Theorem 1 we achieve the following result.

Lemma 1. Suppose a physical experiment reproduces the statistics of the Mayers-Yao reference experiment described in section 3.2. Then the physical measurements X A and Z A anti-commute on the support of the physical state, as do X B and Z B .

This is shown in section C.2. When we apply this result to the remaining measurements in the extended test, we find that X A and Y A anti-commute on the support of the state, as do X B and Y B , Z A and Y A and Z B and Y B . For the remaining discussion we will limit ourselves to the support of the state.
Consider the A side measurements first. We may express Y A as
where the P ranges over the Pauli operators and the E ranges over a basis for the Hermitian operators on S A . Since Y A anti-commutes with X Q A ⊗ I R A S A the coefficients of all the terms with P = X must be 0.
where on the right hand side we have separated out the terms that commute with X Q A ⊗ I R A S A and those that anti-commute. We see that we must have y X,E = −y X,E = 0 and y I,E = −y I,E = 0 for all E.
Applying similar reasoning and the test with Y and Z we find that y Z,E = 0 for all E. Thus
for some Hermitian and unitary M S A . Next we compose Φ with a "phase kickback" circuit consisting of a Hadamard gate on the R A register, followed by a controlled M S A , controlled on the R A register, and a final Hadamard gate on the R A register. This results in a new isometry (we will still call it Φ) such that
This is essentially the well known translation of a two outcome measurement into a qubit measurement. Also, since the addition of the phase kickback did not operate on the junk register the X and Z measurements are not affected. The above process can be repeated for Bob's side, with analogous conclusions. In order to be consistent with the reference experiment, we may construct our isomorphism so that
We have thus shown that the measurements are as in the general simulation. We now turn our attention to the state. From the Mayers-Yao test on X and Z we know that the state on Q A ⊗ Q B (after applying Φ) is |φ + . We next consider the state on the remaining registers, |junk RS . We may express this in the singular value (Schmidt) decomposition, split between R AB and S AB :
with λ j > 0. Since the Y measurement setting gives correlated results (recall we introduced a -1 factor on the B side measurement observable) and the form of Y A and Y B , the states |j R AB must all be +1 eigenvectors of Z R A ⊗ Z R B . If this were not the case then a −1 phase would be introduced and the measurement results would be incorrect at least some of the time. Thus the only possible states for |j R AB are superpositions of |00 and |11 . We do some relabelling and arrive at
with |θ 00 and |θ 11 not necessarily orthogonal. Note that tracing out the S AB ancillae results in a state exactly as described by the multi-party simulation in section 2. Thus we have demonstrated that the physical experiment is equivalent to one of the general simulations of the reference experiment, and completed the proof of Theorem 2.
Suppose that two or more parties are engaged in a cryptographic protocol using self-tested apparatus. The extended Mayers-Yao test above allows them to determine that the devices are implementing a simulation from the family of simulations described in section 2. Suppose further that the adversary, Eve, knows how the devices are implemented and controls the preparation of the state. The honest parties only perform operations as specified for the simulation. Eve, on the other hand, is free to interact with the extra qubits in the simulation in any way she likes. Does this give any advantage to Eve?
Eve can potentially perform many operations, including entangling a qubit of her own with the extra simulation qubits allowing her to perform simulation operations. She may also interact in complex ways with the extra simulation qubits along with the original register. Despite this, we are able to prove that Eve can gain no advantage for some protocols.
We explore a restricted class of protocols that are especially easy to analyse. These are protocols where the only operation that an honest party will do is a Pauli measurement. This class includes the six-state quantum key distribution protocol (implemented in as an entanglement based protocol) [BBBW84], [Bru98]. We will demonstrate that these protocols do not leak any more information when implemented using one of the simulations.
The proof is a series of security reductions to protocols in which each reduction only increases Eve's power. We will show that the final protocol in the reduction is just as secure as the reference protocol (without the simulation applied), hence the simulation protocol is also just as secure as the reference protocol.
For the first reduction we suppose that the participants in the protocol measure their simulation qubit in the Z eigenbasis after the protocol is completed, and transmit the result to Eve. This does not interfere with the intended protocol and only increases Eve's information. Since the Z measurement commutes with all simulation operations, the participants could just as well have performed the measurement before the protocol began. If Eve is the one who prepares the initial state for the simulation (in other cases Eve has strictly less power) then Eve could also perform this measurement herself. This measurement would collapse the state to an eigenvector of the Z measurements and Eve's strategy would be a mixture of different strategies with the states each an eigenvector of the Z measurements.
Let us examine the result of Eve choosing one of these eigenvector states. Each of the parties will receive their extra qubit prepared in a Z eigenvector. The effect of this on their operations is either to perform the protocol's original operation (in the case of a |0 ) or the complex conjugate (in the case of a |1 .) For Pauli measurements, only the Y measurement is affected: the output bit is flipped in the case of the complex conjugate.
If every party receives the same eigenvector in their extra qubit, then the protocol reduces to either the original or the complex conjugate. In either case the security is identical to the original protocol. If the extra qubits are not in the same eigenvector then some Y measurements outcomes will be flipped and some will not. This does not affect Eve's information since she controls which outcomes are flipped and can undo the flips in her reckoning of the final classical information. Note that the bit flips may introduce errors into the protocol. If the protocol does not explicitly check for such errors (as does the 6-state protocol) information will still not be leaked to Eve, however a test for these errors may be required to make sure the protocol functions correctly. The final protocol, and hence the simulation, is thus as secure as the original protocol.

Conclusions

Theorem 2, along with the security result of section 5, allows us to analyze the case of the 6-state QKD protocol in the self-tested framework. In particular we may define a self-testing version of the 6-state protocol in which the extended Mayers-Yao test is incorporated along with the usual 6-state protocol. Given a robust version of the test (see section 6.2) we may first estimate the state and measurement observables, then apply a security proof for the 6-state protocol in order to derive a secure key rate.
Although a self-tested 6-state protocol is currently not practical, nor likely to become so, the result is interesting from a theoretical perspective within the self-tested framework. Previous results were limited to real Hilbert spaces, one could apply the real simulation explicitly within the reference experiment and then proceed with the self-test. This works fine for circuits, where only the correct outcome is important, however the 6-state protocol introduces other concerns, namely the possibility of information leaking to an adversary. The current work thus illustrates how a self-test for complex operations provides additional benefit over the previous self-tests.

Future work

Note that we have not described a physically realizable test in section 4. The proof requires that the expected value of the observables match the reference exactly. This cannot be established physically without some kind of repeatability assumptions and an infinite number of trials. The original test by Mayers and Yao was shown to be robust in [MMMO06], establishing a polynomial relationship between the precision of the statistics and the closeness to an EPR state. We are currently studying the robustness of these new tests. This is an important line of future research. A related task is to extend the results to continuous variable systems.
Another interesting line of research is to follow the same path as Magniez et al. to obtain a self-testing circuit for arbitrary circuits, now allowing complex gates. The framework and proofs from [MMMO06] offer a roadmap for such research, but there are some technical problems that arise along the way so a straightforward adaptation is not possible. These are due to the larger Hilbert space created when adding the extra qubits to allow the simulations.

Continuous time evolution

We begin with a Hamiltonian H. One can simulate the Schrödinger evolution of H on |ψ by evolving H * on |ψ * backwards in time, or equivalently, evolving the system according to −H * , and measuring with conjugated observables.
Thus, the simulation of the evolution of H can be achieved using the Hamiltonian
The evolution of the state according to the Schrödinger equation
gives (14) (using the fact that exp(A + B) = exp(A) + exp(B) when AB = 0 = BA, and that exp (P ⊗ A) = P ⊗ exp(A) when P 2 = P ). Thus
and the simulation evolution tracks that of the reference system. Another way to arrive at the same H ′ is the approach used in the real simulation [MMG09]. There, rather than considering the Hamiltonian alone, the whole matrix in the exponent, −iHt, was considered. Applying C(·) to this matrix we obtain
Here the fact that a * b * = (ab) * means (−iH) * = iH * and the −1 factor is explained.

B Real simulation in the family

The real simulation presented in [MMG09] can be expressed as a simulation in the family defined above through a change of basis. Starting with the state defined as in 1 with a = c = 1 2 the simulation state is pure and equal to
We next apply a Hadamard gate followed by the relative phase rotation 1 0 0 −i to the extra qubit. This is the same as applying the unitary
The resulting state is 1 2 |0 (|ψ + |ψ * ) − i 2 |1 (|ψ − |ψ * ) which can be rewritten as
which is exactly the operator used in the real simulation for M . The states used in the multi-party simulation in [MMG09] are stabilized by Y s ⊗ Y t for distinct s, t. Also note that the states used in the simulations defined here are stabilized by Z s ⊗ Z t for distinct s, t. The qubit-wise transformation applied transformations Z into Y , so the multi-party states are also transformed correctly.

C Simplified proof for Mayers-Yao self-test


C.1 Proof Overview

The main advantages of the following new proof for the Mayers-Yao self-test is that it is shorter, clearer, and more naturally extends to the more general test given in this paper.
The proof has two distinct parts. The first part establishes some equations on the state and observables based on the observed statistics. These are straightforward and are a direct result of the statistics observed. Next we use these equations to show that the X and Z observables on each side anti-commute on the support of the state. The second part uses the anti-commuting observables to construct local isometries that take the state and observables to the reference state and observables.
One important consideration is that of the support of the state. Since we do not make any claims about the state and observables outside the support of the state we disregard the rest of the Hilbert space. In this way we will not make any more reference to the support of the state. Additionally, X and Z measurements are uncorrelated.
φ + | X ⊗ Z |φ + = 0.
The interesting part comes when we measure X or Z on one side and D on the other.
φ + | X ⊗ D |φ + = φ + | Z ⊗ D |φ + = 1 √ 2 .

C. 2

2Observed statistics imply anti-commuting observables Statistics In the reference test the marginals for each observable are all 0. That is, φ + | M ⊗ I |φ + = 0 for M ∈ {X, Z, D}. (Swapping the systems in this and the following equations gives the same result since |φ + is symmetric.) Measuring the same observable on both sides always give identical outcomes. Thus φ + | M ⊗ M |φ + = 1.
We may consider mixed states as well, but it is not necessary for our discussion.
This part of the real simulation was previously well known
on the relevant subspace, and linearity.This concludes the proof of Theorem 1 .
Acknowledgements This work is supported by Canada's NSERC, QuantumWorks, Ontario Centres of Excellence, MITACS, CIFAR, CRC, ORF, the Government of Canada, and Ontario-MRI.A Evolution in simulationsWe can extend the measurement operator defined in 2 to arbitrary operators. We defineNote that C(M ) can be expressed differently aswhere Re(M ) and Im(M ) are the real and imaginary parts of M (both real matrices). In the case of a multi-party simulation, the Z operates on a particular party's added qubit. We summarize some of the properties of C(M ) hereLemma 2. Let M and N be matrices. Then we have the following: These properties can be derived easily.Discrete time evolution The properties of C(·) allow us to easily determine how the simulation states in the continuum evolve. Let U and |ψ be a reference unitary operation and state and let ρ ′ be as in equation 1. By the form of C(U ) we haveBut this is the simulation state for U |ψ , and hence C(U ) evolves the simulation state ρ ′ to produce a new simulation state corresponding to U |ψ . Compositions of unitaries will also evolve the state correctly so that the measurement statistics at the end of a circuit will be identical to that of the reference circuit.General quantum operations may be mapped similarly. It is easy to verify that in Kraus representation a completely positive map is mapped to a completely positive map if we apply C(·) to each of the Kraus operators. The trace preserving property is also preserved. We apply the same reasoning as for U above to with each Kraus operator. The linearity of C then allows us to conclude that the simulation map will behave correctly. That is to say, it will map ρ ′ to a new simulation state corresponding to |ψ evolved under the reference map.Applying some equations and the anti-commuting result from the previous section we find that this is equal toThis may look curious since I + Z A and I + Z B are not unitary. In fact it is easy to show that the final state still has the correct norm. To give some intuition, note that in the reference case we want to extract |φ + and swap in |00 = 1 2 √ 2 (I + Z) ⊗ (I + Z) |φ + .Measurement operatorsWe now turn to equivalence of the measurement operators. We start with X A (the result for X B follows analogously). Applying X A to |ψ before applying the circuit is the same as applying it at the end, with a −1 phase introduced by anti-commuting past the controlled Z A operation (recall from section C.2 that X A and Z A anti-commute on the relevant subspace). The resulting state isFollowing the same logic as used in the state equivalence, we find that the final state is Φ A ⊗ Φ B (X A ⊗ I |ψ ) = 1 √ 2 (I ⊗ I + I ⊗ Z B ) |ψ (X ⊗ I) |φ + For the Z A operation, we see that the effect is a −1 phase kicked back through the final controlled X A operation. This phase appears on the terms with |1 in the qubit, exactly as if a Z operation had been applied to the qubit. The equivalence for the D operators results from the fact that D = X+Z √
Eavesdrop-detecting quantum communications channel. C H Bennett, G Brassard, S Breidbart, S Wiesner, IBM Technical Disclosure Bulletin. 268C. H. Bennett, G. Brassard, S. Breidbart, and S Wiesner. Eavesdrop-detecting quantum communications channel. IBM Technical Disclosure Bulletin, 26(8):4363 -4366, January 1984.
Optimal eavesdropping in quantum cryptography with six states. Dagmar Bruß, 10.1103/PhysRevLett.81.3018Phys. Rev. Lett. 8114Dagmar Bruß. Optimal eavesdropping in quantum cryptography with six states. Phys. Rev. Lett., 81(14):3018-3021, Oct 1998. doi:10.1103/PhysRevLett.81.3018.
Simulating quantum systems using real Hilbert spaces. Nicolas Gisin, 10.1103/PhysRevLett.102.020505arXiv:quant-ph/0702021v2.MMG09Physical Review Letters. 102220505Matthew McKague, Michele Mosca, and Nicolas GisinNicolas Gisin. Bell inequalities: many questions, a few answers, 2007. eprint arXiv:quant-ph/0702021v2. MMG09. Matthew McKague, Michele Mosca, and Nicolas Gisin. Simulating quantum systems using real Hilbert spaces. Physical Review Letters, 102(2):020505, 2009. doi:10.1103/PhysRevLett.102.020505. eprint arXiv:0810.1923, url http://link.aps.org/abstract/PRL/v102/e020505.
Self-testing of quantum circuits. Frédéric Magniez, Dominic Mayers, Michele Mosca, Harold Ollivier, arXiv:quant-ph/0512111v1Proceedings of the 33rd International Colloquium on Automata, Languages and Programming, number 4052 in Lecture Notes in Computer Science. M et al. Bugliesithe 33rd International Colloquium on Automata, Languages and Programming, number 4052 in Lecture Notes in Computer ScienceFrédéric Magniez, Dominic Mayers, Michele Mosca, and Harold Ollivier. Self-testing of quantum cir- cuits. In M et al. Bugliesi, editor, Proceedings of the 33rd International Colloquium on Automata, Lan- guages and Programming, number 4052 in Lecture Notes in Computer Science, pp. 72-83, 2006. eprint arXiv:quant-ph/0512111v1 .
Quantum cryptography with imperfect apparatus. Dominic Mayers, Andrew Yao, arXiv:quant-ph/9809039FOCS. Dominic Mayers and Andrew Yao. Quantum cryptography with imperfect apparatus. In FOCS, pp. 503-509, September 1998. eprint arXiv:quant-ph/9809039.
Self testing quantum apparatus. Dominic Mayers, Andrew Yao, arXiv:quant-ph/0307205QIC. 44Dominic Mayers and Andrew Yao. Self testing quantum apparatus. QIC, 4(4):273-286, July 2004. eprint arXiv:quant-ph/0307205.
Self-testing of universal and faulttolerant sets of quantum gates. Frederic Wim Van Dam, Michele Magniez, Miklos Mosca, Santha, 10.1145/335305.335402STOC '00: Proceedings of the thirty-second annual ACM symposium on Theory of computing. New York, NY, USAACMWim van Dam, Frederic Magniez, Michele Mosca, and Miklos Santha. Self-testing of universal and fault- tolerant sets of quantum gates. In STOC '00: Proceedings of the thirty-second annual ACM symposium on Theory of computing, pp. 688-696, New York, NY, USA, 2000. ACM. doi:doi:10.1145/335305.335402. eprint arXiv:quant-ph/9904108 .


6197709:Measurement-based quantum computation on cluster states


I. INTRODUCTION

Recently, we introduced the scheme of the one-way quantum computer (QC C ) ͓1͔. This scheme uses a given entangled state, the so-called cluster state ͓2͔, as its central physical resource. The entire quantum computation consists only of a sequence of one-qubit projective measurements on this entangled state. Thus, it uses measurements as the central tool to drive a computation ͓3-6͔. We called this scheme the ''one-way quantum computer'' since the entanglement in the cluster state is destroyed by the one-qubit measurements and therefore it can only be used once. To emphasize the importance of the cluster state for the scheme, we use the abbreviation QC C for ''one-way quantum computer.''
The QC C is universal since any unitary quantum logic network can be simulated on it efficiently. The QC C can thus be explained as a simulator of quantum logic networks. However, the computational model that emerges for the QC C ͓7͔ makes no reference to the concept of unitary evolution and it shall be pointed out from the beginning that the network model does not provide the most suitable description for the QC C . Nevertheless, the network model is the most widely used form of describing a quantum computer and therefore the relation between the network model and the QC C must be clarified.
The purpose of this paper is threefold. First, it is to give the proof for universality of the QC C ; second, to relate quantum algorithms to graphs; and third, to provide a number of examples for QC C circuits, which are characteristic and of practical interest.
In Sec. II we give the universality proof for the described scheme of computation in a complete and detailed form. The proof has already been presented to a large part in Ref. ͓1͔. What was not contained in Ref. ͓1͔ was the explanation of why and how the gate simulations on the QC C work. This omission seemed in order since the implementation of the gates discussed there ͓controlled NOT ͑CNOT͒ and arbitrary rotations͔ requires only small clusters such that the functioning of the gates can be easily verified in a computer simula-tion. For the examples of gates and subcircuits given in Sec. IV, this is no longer the case. Generally, we want an analytic explanation for the functioning of the gate simulations on the QC C . This explanation is given in Sec. II F and applied to the gates of a universal set in Sec. II G as well as to more complicated examples in Sec. IV.
In Sec. II H we discuss the spatial, temporal, and operational resources required in QC C computations in relation to the resources needed for the corresponding quantum logic networks. We find that overheads are at most polynomial. But there does not always need to be overheads. For example, as shown in Sec. II I, all QC C circuits in the Clifford group have unit logical depth.
In Sec. III we discuss non-network aspects of the QC C . In Sec. III A we state the reasons why the network model is not adequate to describe the QC C in every respect. The network model is abandoned and replaced by a more appropriate model ͓7͔. This model is described very briefly.
In Sec. III B we relate algorithms to graphs. We show that from every algorithm its Clifford part can be removed. The required algorithm-specific nonuniversal quantum resource to run the remainder of the quantum algorithm on the QC C is then a graph state ͓9͔. All that remains of the Clifford part is a mathematical graph specifying this graph state.
In Sec. IV we give examples of larger gates and subcircuits, which may be of practical relevance, among them the QC C circuit for quantum Fourier transformation and for the n-qubit adder.
In Sec. V we discuss the QC C computations on finite ͑small͒ clusters and in the presence of decoherence. We describe a variant of the scheme consisting of repeated steps of ͑re-͒entangling a cluster via the Ising interaction, alternating with rounds of one-qubit measurements. Using this modified scheme it is possible to split long computations such that they fit piecewise on a small cluster.

II. UNIVERSALITY OF QUANTUM COMPUTATION VIA ONE-QUBIT MEASUREMENTS

on the QC C . Before we go into details, let us state the general picture.
For the one-way quantum computer, the entire resource for the quantum computation is provided initially in the form of a specific entangled state-the cluster state ͓2͔-of a large number of qubits. Information is then written onto the cluster, processed, and read out from the cluster by one-particle measurements only. The entangled state of the cluster thereby serves as a universal ''substrate'' for any quantum computation. It provides in advance all entanglement that is involved in the subsequent quantum computation. Cluster states can be created efficiently in any system with a quantum Ising-type interaction ͑at very low temperatures͒ between two-state particles in a lattice configuration.
It is important to realize here that information processing is possible even though the result of every measurement in any direction of the Bloch sphere is completely random. The mathematical expression for the randomness of the measurement results is that the reduced density operator for each qubit in the cluster state is 1 2 1. The individual measurement results are random but correlated, and these correlations enable quantum computation on the QC C .
For clarity, let us emphasize that in the scheme of the QC C we distinguish between cluster qubits on C, which are measured in the process of computation, and the logical qubits. The logical qubits constitute the quantum information being processed, while the cluster qubits in the initial cluster state form an entanglement resource. Measurements of their individual one-qubit state drive the computation.
To process quantum information with this cluster, it suffices to measure its particles in a certain order and in a certain basis, as depicted in Fig. 1. Quantum information is thereby propagated through the cluster and processed. Measurements of z observables effectively remove the respective lattice qubit from the cluster. Measurements in the x ͑and y ) eigenbasis are used for ''wires,'' i.e., to propagate logical quantum bits through the cluster, and for the CNOT gate between two logical qubits. Observables of the form cos() x Ϯsin() y are measured to realize arbitrary rotations of logical qubits. For these cluster qubits, the basis in which each of them is measured depends on the results of preceding measurements. This introduces a temporal order in which the measurements have to be performed. The processing is finished once all qubits except a last one on each wire have been measured. The remaining unmeasured qubits form the quantum register which is now ready to be read out. At this point, the results of previous measurements determine in which basis these ''output'' qubits need to be measured for the final readout, or if the readout measurements are in the x , y , or z eigenbasis, how the readout measurements have to be interpreted. Without loss of generality, we assume in this paper that the readout measurements are performed in the z eigenbasis.

A. Cluster states and their quantum correlations

Cluster states are pure quantum states of two-level systems ͑qubits͒ located on a cluster C. This cluster is a connected subset of a simple cubic lattice Z d in dу1 dimensions. The cluster states ͉ ͕͖ ͘ C obey the set of eigenvalue equations K (a) ͉ ͕͖ ͘ C ϭ͑Ϫ1 ͒ a ͉ ͕͖ ͘ C ,

͑1͒

with the correlation operators
Therein, ͕͖ª͕ a ͕0,1͖͉ aC͖ is a set of binary parameters that specify the cluster state and nghb(a) is the set of all neighboring lattice sites of a.
A cluster state ͉ ͕͖ ͘ C is completely specified by the eigenvalue equations ͑1͒, since K (a) , aC, form a complete set of ͉C͉ independent and commuting observables for the system of qubits on the cluster C. This can most easily be seen from the fact that K (a) is obtained from x (a) under conjugation with a unitary transformation, as shown below Eq. ͑11͒. For a set of eigenvalues specified by ͕͖ the corresponding eigenspace is thus one-dimensional, i.e., ͉ ͕͖ ͘ C is determined modulo an irrelevant phase factor. There are 2 ͉C͉ different choices for ͕͖͕0,1͖ ͉C͉ , and since K (a) are Hermitian operators, the associated common eigenstates, the cluster states, are mutually orthogonal and form a basis in the Hilbert space of the cluster.
The discussion in this paper will be based entirely on eigenvalue equations ͑1͒ and we will never need to work out some cluster state in any specific basis. In fact, to write down a cluster state in its explicit form would be quite space consuming since the minimum number of required terms scales exponentially with the number of qubits ͓2͔, and for computation we will be going to consider rather large cluster states. Nevertheless, for illustration we give a few examples for cluster states of a small number of qubits. The cluster states on a chain of 2, 3, and 4 qubits, fulfilling eigenvalue equations ͑1͒ with all a ϭ0, are ͉͘ C 2 ϭ 1 ͱ2 ͉͑0͘ 1 ͉ϩ͘ 2 ϩ͉1͘ 1 ͉Ϫ͘ 2 ), FIG. 1. Simulation of a quantum logic network by measuring two-state particles on a lattice. Before the measurements the qubits are in the cluster state ͉͘ C of Eq. ͑1͒. Circles ᭪ symbolize measurements of z , vertical arrows are measurements of x , while tilted arrows refer to measurements in the x-y-plane.
͉͘ C 3 ϭ 1 ͱ2 ͉͑ϩ͘ 1 ͉0͘ 2 ͉ϩ͘ 3 ϩ͉Ϫ͘ 1 ͉1͘ 2 ͉Ϫ͘ 3 ), ͑3͒
͉͘ C 4 ϭ 1 2 ͉ϩ͘ 1 ͉0͘ 2 ͉ϩ͘ 3 ͉0͘ 4 ϩ 1 2 ͉ϩ͘ 1 ͉0͘ 2 ͉Ϫ͘ 3 ͉1͘ 4 , ϩ 1 2 ͉Ϫ͘ 1 ͉1͘ 2 ͉Ϫ͘ 3 ͉0͘ 4 ϩ 1 2 ͉Ϫ͘ 1 ͉1͘ 2 ͉ϩ͘ 3 ͉1͘ 4 , with the notation ͉0͘ a ª͉0͘ a,z ϭ z (a) ͉0͘ a,z , ͉1͘ a ª͉1͘ a,z ϭϪ z (a) ͉1͘ a,z , ͑4͒
The state ͉͘ C 2 is local unitary equivalent to a Bell state and ͉͘ C 3 to the Greenberger-Horne-Zeilinger ͑GHZ͒ state. ͉͘ C 4 , however, is not equivalent to a four-particle GHZ state. In particular, the entanglement in ͉͘ C 4 cannot be destroyed by a single local operation ͓2͔.
Ways to create a cluster state, in principle, are to measure all the correlation operators K (a) , aC of Eq. ͑2͒ on an arbitrary ͉C͉-qubit state or to cool into the ground state of a Hamiltonian H K ϭϪបg ͚ aC a K (a) .
Another way-likely to be more suitable for realization in the lab-is as follows. First, a product state ͉ϩ͘ C ϭ aC ͉ϩ͘ a is prepared. Second, the unitary transformation S (C) ,
is applied to the state ͉ϩ͘. Often we will write S in short for S (C) . In Eq. ͑5͒, for the cases of dimension d ϭ1,2,3, we have ␥ 1 ϭ͕1͖, ␥ 2 ϭ͕(1,0) T ,(0,1) T ͖, and ␥ 3 ϭ͕(1,0,0) T ,(0,1,0) T ,(0,0,1) T ͖, and the two-qubit transformation S ab is such that the state ͉1͘ a ͉1͘ b acquires a phase of under its action, while the remaining states ͉0͘ a ͉0͘ b , ͉0͘ a ͉1͘ b , and ͉1͘ a ͉0͘ b acquire no phase. Thus, S ab has the form
which is a conditional phase gate between a and b. Note that all operations S ab in S mutually commute and that they can therefore be carried out at the same time. Initial individual preparation of the cluster qubits in ͉ϩ͘ aC can also be done in parallel. Thus, the creation of the cluster state is a two-step process. The temporal resources to create the cluster state are constant in the size of the cluster.
The state ͉ϩ͘ C obviously obeys the eigenvalue equations x (a) ͉ϩ͘ C ϭ͉ϩ͘ C , ᭙aC and thus the cluster state ͉͘ C generated via S obeys
To obtain S x (a) S † , we use the evolution relations for the stabilizer of a state under the action of a phase gate ͓10͔. We observe that
Further, the Pauli phase flip operators z (d) commute with all S ab , i.e.,
Thus, the state ͉͘ C generated from ͉ϩ͘ C via the transformation S as defined in Eq. ͑5͒ does indeed obey eigenvalue equations of form ͑1͒, with a ϭ0, ᭙aC. ͑12͒
As the eigenvalues are fixed in this case, we drop them in the notation for the cluster state ͉͘ C . Cluster states specified by different sets ͕ a ͖ can be obtained by applying Pauli phase flip operators z (a) . To see this, note that
where the addition for a is modulo 2. Cluster states with different sets ͕͖ are equally suited for QC C computation.
Concerning a physical realization of the transformation S defined in Eq. ͑5͒, note that S is generated by the Hamiltonian
Now, Sϭexp(Ϫi/បgH) may be written in the form

͑16͒

We find that the interaction part H I of the Hamiltonian H generating S is of the Ising form,
and, since the local part H local of the Hamiltonian commutes with the Ising Hamiltonian H I , the interaction S generated by H is local unitary equivalent to the unitary transformation generated by a Ising Hamiltonian. For matter of presentation, the interaction S ab in Eq. ͑6͒ and, correspondingly, the local part of the Hamiltonian H in Eq. ͑15͒ has been chosen in such a way that eigenvalue equations ͑1͒ take the particularly simple form with a ϭ0 for all aC, irrespective of the shape of the cluster.
To create quantum states that are useful as a resource for the QC C , i.e., cluster-or local unitary equivalent states, all systems with a tunable Ising interaction and a local z -type Hamiltonian, i.e., with a Hamiltonian
are suitable, provided the coupling g(t) can be switched between zero and at least one nonzero value. Even this condition can be relaxed. A permanent Ising interaction instead of a globally tunable one is sufficient, if the measurement process is much faster than the characteristic time scale for the Ising interaction, i.e., if the measurements are stroboscopic. If it takes the Ising interaction a time T Ising to create a cluster state ͉͘ C from a product state ͉ϩ͘ C , then the Ising interaction acting for a time 2T Ising performs the identity operation, S (C) S (C) ϭ1 (C) . Therefore, starting with a product state ͉ϩ͘ C at time tϭ0 evolving under permanent Ising interaction, stroboscopic measurements may be performed at times (2kϩ1)T Ising ,kN.
One possibility to create a cluster state in practice is via cold controlled collisions in optical lattices, as described in Ref. ͓2͔. Cold atoms representing the qubits can be arranged on a two-or three-dimensional ͑3D͒ lattice and statedependent interaction phases may be acquired via cold collisions between neighboring atoms ͓14͔ or via tunneling ͓15͔. For a suitable choice of the collision phases , ϭ mod 2, the state resulting from a product state ͉ϩ͘ C after interaction is a cluster state obeying eigenvalue equations ͑1͒, with the set ͕ a ,aC͖ specified by the filling pattern of the lattice.
Let us, at the end of this section, briefly state which techniques will be used for the explanation of measurementbased quantum computation on cluster states. First, note that the operators (Ϫ1) a K (a) in Eq. ͑1͒ generate the stabilizer of the state ͉ ͕͖ ͘ C . The stabilizer formalism, as developed by Gottesman ͓10,11͔ and by Calderbank et al. ͓12͔ ͑see also Ref. ͓13͔͒, provides a compact characterization of the cluster state. It is also useful in understanding some of the working principles of the QC C . In the subsequent sections, we frequently perform stabilizer manipulations.
Further, some basic notions of graph theory will be useful later when we discuss the relation between quantum algorithms and graphs in Sec. III B. Therefore, let us, at this point, establish a connection between quantum states such as the cluster state of Eq. ͑1͒, and graphs. The treatment here follows that of Ref. ͓9͔, adapted to our notation.
Let us recall the definition of a graph ͓16͔. A graph G(V,E) is a set V of vertices connected via edges e from the set E. The information of which vertex aV is connected to which other vertex bV is contained in a symmetric ͉V͉ϫ͉V͉ matrix ⌫, the adjacency matrix. The matrix ⌫ is such that ⌫ ab ϭ1 if two vertices a and b are connected via an edge eE, and ⌫ ab ϭ0 otherwise. We identify the cluster C with the vertices V C of a graph, CϭV C , and in this way establish a connection to the notion introduced earlier.
To relate graphs to quantum mechanics, the vertices of a graph can be identified with local quantum systems, in this case qubits, and the edges with two-particle interactions, in the present case z z interactions. If one initially prepares each individual qubit a in the state ( z (a) ) a ͉ϩ͘ a and subsequently switches on, for an appropriately chosen finite time span, the interaction
with (a,b)E denoting an edge between qubits a and b, then one obtains quantum states that are graph code words as introduced in Ref. ͓9͔. Henceforth we will refer to these graph code words as graph states and use them in a context different from coding. The graph states ͉͕͖͘ G are defined by a set of eigenvalue equations, which read
with a ͕0,1͖, ᭙aV. Here we use G instead of V as an index for the state ͉͘, as the set EʚVϫV of edges is now independent and no longer implicitly specified by V as was the case in Eq. ͑1͒. Note that cluster states ͑1͒ are a particular case of graph states ͑20͒. The graph G(C,E C ) that describes a cluster state is that of a square lattice in 2D and that of a simple cubic lattice in 3D, i.e., the set E C of edges is given by

B. A universal set of quantum gates

To provide something definite to discuss right from the beginning, we now give the procedures of how to realize a CNOT gate and a general one-qubit rotation via one-qubit measurements on a cluster state. The explanation of why and how these gates work will be given in Sec. II G.
A CNOT gate can be realized on a cluster state of 15 qubits, as shown in Fig. 2. All measurements can be performed simultaneously. The procedure to realize a CNOT gate on a cluster with 15 qubits, as displayed in Fig. 2, is the following.
Procedure 1. Realization of a CNOT gate acting on a twoqubit state ͉ in ͘.
͑1͒ Prepare the state
͑2͒ Entangle the 15 qubits of the cluster C 15 via the unitary operation S (C 15 ) .
͑3͒ Measure all qubits of C 15 except for the output qubits 7, 15 ͑following the labeling in Fig. 2͒. The measurements can be performed simultaneously. Qubits 1,9,10,11,13,14 are measured in the x eigenbasis and qubits 2-6, 8, 12 in the y eigenbasis.
Dependent on the measurement results, the following gate is thereby realized:
where the byproduct operator U ⌺,CNOT has the form
with ␥ x (c) ϭs 2 ϩs 3 ϩs 5 ϩs 6 , ␥ x (t) ϭs 2 ϩs 3 ϩs 8 ϩs 10 ϩs 12 ϩs 14, ͑23͒ ␥ z (c) ϭs 1 ϩs 3 ϩs 4 ϩs 5 ϩs 8 ϩs 9 ϩs 11 ϩ1, ␥ z (t) ϭs 9 ϩs 11 ϩs 13 .
Therein, the s i represent the measurement outcomes s i on the qubits i. Expression ͑23͒ is modified if redundant cluster qubits are present and/or if the cluster state on which the CNOT gate is realized is specified by a set ͕ a ͖ different from Eq.
͑12͒; see Sec. II C. This concludes the presentation of the CNOT gate, the proof of its functioning is given in Sec. II G. An arbitrary rotation U Rot SU(2) can be realized on a chain of five qubits. Consider a rotation in its Euler representation
where the rotations about the x and z axes are
Initially, the first qubit is prepared in some state ͉ in ͘, which is to be rotated, and the other qubits are prepared in ͉ϩ͘.
After the five qubits are entangled by the unitary transformation S, the state ͉ in ͘ can be rotated by measuring qubits 1-4. At the same time, the state is also swapped to site 5. The qubits 1-4 are measured in appropriately chosen bases
whereby the measurement outcomes s j ͕0,1͖ for j ϭ1, . . . ,4 are obtained. Here, s j ϭ0 means that qubit j is projected into the first state of B j ( j ). In Eq. ͑26͒ the basis states of all possible measurement bases lie on the equator of the Bloch sphere, i.e., on the intersection of the Bloch sphere with the x-y plane. Therefore, the measurement basis for qubit j can be specified by a single parameter, the measurement angle j . The measurement direction of qubit j is the vector on the Bloch sphere that corresponds to the first state in the measurement basis B j ( j ). Thus, the measurement angle j is the angle between the measurement direction at qubit j and the positive x axis. In summary, the procedure to realize an arbitrary rotation U Rot ͓,,͔, specified by its Euler angles ,,, is the following. Procedure 2. Realization of general one-qubit rotations U Rot SU(2).
͑1͒ Prepare the state
͑2͒ Entangle the five qubits of the cluster C 5 via the unitary operation S (C 5 ) .
͑3͒ Measure qubits 1-4 in the following order and basis:
Via Procedure 2 the rotation U Rot Ј is realized:

͑28͒

Therein, the random byproduct operator has the form U ⌺,Rot ϭ x s 2 ϩs 4 z s 1 ϩs 3 . ͑29͒
It can be corrected for at the end of the computation, as will be explained in Sec. II E.
There is a subgroup of rotations for which the realization procedure is somewhat simpler than Procedure 2. These ro-tations form the subgroup of local operations in the Clifford group. The Clifford group is the normalizer of the Pauli group.
Among these rotations are, for example, the Hadamard gate and the /2-phase gate. These gates can be realized on a chain of five qubits in the following way.
Procedure 3. Realization of the Hadamard and the /2-phase gates.
͑1͒ Prepare the state
͑2͒ Entangle the five qubits of the cluster C 5 via the unitary operation S (C 5 ) .
͑3͒ Measure qubits 1-4. This can be done simultaneously. For the Hadamard gate, measure individually the observables x (1) , y (2) , y (3) , y (4) . For the /2-phase gate measure
.
The difference with respect to Procedure 2 for general rotations is that in Procedure 2 no measurement bases need to be adjusted according to previous measurement results and, therefore, the measurements can all be performed at the same time.
As in the cases before, the Hadamard and the /2-phase gates are performed only modulo a subsequent byproduct operator, which is determined by the random measurement outcomes s k , U ⌺,H ϭ x s 1 ϩs 3 ϩs 4 z s 2 ϩs 3 , ͑30͒ U ⌺,U z (/2) ϭ x s 2 ϩs 4 z s 1 ϩs 2 ϩs 3 ϩ1 .
Before we explain the functioning of the above gates, we would like to address the following questions: First,''How does one manage to occupy only those lattice sites with cluster qubits that are required for a particular circuit but leave the remaining ones empty?'' The answer to this question is that redundant qubits will not have to be removed physically. It is sufficient to measure each of them in the z eigenbasis, as will be described in Sec. II C.
Second, ''How can the described procedures for gate simulation be concatenated such that they represent a measurement-based simulation of an entire circuit?'' It seems at first sight that the described building blocks would only lead to a computational scheme consisting of repeated steps of entangling operations and measurements. This is not the case. As will be shown in Sec. II D, the three procedures stated are precisely of such a form that the described measurement-based scheme of quantum computation can be decomposed into them.
The third question is ''How does one deal with the randomness of the measurement results that leads to the byproduct operators ͑23͒, ͑29͒, and ͑30͒?'' The appearance of byproduct operators may suggest that there is a need for local correction operations to counteract these unwanted extra operators. However, there is neither a possibility for such counter rotations within the described model of quantum computation, nor is there a need. The scheme works with unit efficiency despite the randomness of the individual measurement results, as will be discussed in Sec. II E.

C. Removing the redundant cluster qubits

A cluster state on a two-dimensional cluster of rectangular shape, say, is a resource that allows for any computation that fits on the cluster. If one realizes a certain quantum circuit on this cluster state, there will always be qubits on the cluster, which are not needed for its realization. Such cluster qubits we call redundant for this particular circuit.
In the description of the QC C as a quantum logic network, the first step of each computation will be to remove these redundant cluster qubits. Fortunately, the situation is not such that we have to remove the qubits ͑or, more precisely, the carriers of the qubits͒ physically from the lattice. To make them ineffective to the realized circuit, it suffices to measure each of them in the z eigenbasis. In this way, one is left with an entangled quantum state on the cluster C N of the unmeasured qubits and a product state on C\C N ,

͑31͒

with ͉Z͘ C\C N ϭ( iC\C N ͉s i ͘ i,z ) and s i the results of the z measurements. The resulting entangled state ͉ ͕ Ј ͖ ͘ C N on the subcluster C N is again a cluster state obeying the set of Eqs. ͑1͒, and the measurement outcomes determine the sign factors therein. This can be easily seen with stabilizer methods ͓10,13͔. Nevertheless, for completeness we give the argument here. First, by definition, we have

͑32͒

Using eigenvalue equations ͑1͒, we now insert a correlation operator K (a) with aC N into the right-hand side ͑rhs͒ of Eq. ͑32͒ between the projector and the state, and obtain

͑33͒

with the correlation operators
and the set ͕ a Ј͖ specifying the eigenvalues
As the new correlation operators KЈ (a) in Eq. ͑33͒ only act on the cluster qubits in C N , the states ͉ ͕ Ј ͖ ͘ C N again obey eigenvalue equations of type ͑1͒, i.e.,
There are ͉C N ͉ such eigenvalue equations for a state of ͉C N ͉ qubits. Thus, the state ͉ ͕ Ј ͖ ͘ C N is specified by Eq. ͑36͒ up to a global phase.
From Eq. ͑35͒ we find that the redundant qubits have some remaining influence on the process of computation. After they have been measured, the random measurement results enter into the eigenvalues that specify the residual cluster state ͉ ͕ Ј ͖ ͘ C N on the cluster C N . However, from Eq. ͑14͒ it follows that ͉ ͕ Ј ͖ ͘ C N is equivalent to ͉͘ C N modulo local z rotations. These can be accounted for by absorbing them into the subsequent measurements.
In this way, a QC C computation with arbitrary ͕ a Ј͖ may always be traced back to the case of ͕ a Јϭ0͉᭙aC N ͖, and we therefore adopt the following two rules to simplify the further discussion:
͑1͒ The redundant cluster qubits are discarded. We only consider the subcluster C N . ͑37͒
͑ 2 ͒ We assume that a Јϭ0 for all aC N .

D. Concatenation of gate simulations

A quantum circuit on the QC C is a spatial and temporal pattern of measurements on individual qubits, which have previously been entangled to form a cluster state. To better understand its functioning we would like-as in the network model of quantum computation-to decompose the circuit into basic building blocks. These building blocks should be such that out of them any circuit can be assembled. In explaining the QC C in a network language, we can relate the building blocks of a quantum logic network-the quantum gates-to building blocks of QC C circuits. To do so, we need to prove that, in a QC C computation, measurement patterns representing the gates can be patched together like the quantum gates themselves. This proof is given in the following.
To realize a gate g on the QC C , consider a cluster C(g). This cluster has an input section C I (g), a body C M (g), and an output section C O (g), with
The measurement bases of the qubits in C M (g), the body of the gate g, encode g. The general scheme for procedures to realize a gate g on a cluster C(g), for which examples have been given with Procedures 1-3 for the CNOT gate and the rotations, is the following.
Scheme 1. Simulation of the gate g on C(g), acting on the input state ͉͘ in .
͑1͒ Prepare the input state ͉ in ͘ on C I (g) and the qubits in C M (g)ഫC O (g) individually in the state ͉ϩ͘ϭ͉0͘ x such that the quantum state of all qubits in C(g) becomes
such that the resulting quantum state is ͉⌿ ͘ C N ϭS "C(g)… ͉⌿ in ͘ C(g) .
͑3͒ Measure the cluster qubits in C I (g)ഫC M (g), i.e., choose measurement bases specified by r ជ k S 2 , k C I (g)ഫC M (g) and obtain the random measurement results s k such that the projector
is applied; thereby the state ͉⌿ out ͘ C(g) is obtained.
Putting all three steps of Scheme 1 together, the relation between ͉⌿ in ͘ C(g) and ͉⌿ out ͘ C(g) is

͑42͒

As we will show later, the state ͉⌿ out ͘ C(g) has the form
where ͉s k ͘ k,r ជ k denotes the state of the qubit k after the observable r ជ k • ជ (k) has been measured and the measurement outcome was s k , and ͉ out ͘ϭU ⌺,g U g ͉ in ͘.

͑44͒

Therein, U g is the desired unitary operation, and the byproduct operator U ⌺,g is an extra multilocal rotation that depends on the measurement results ͕s k ͉kC I (g)ഫC M (g)͖. The byproduct operator is always in the Pauli group, i.e.,
modulo a possible global phase, and n is the number of logical qubits. In Eq. ͑45͒ [i] denote Pauli operators acting on the logical qubit i, not cluster qubit. The values x i ,z i ͕0,1͖ are computed from the outcomes of the measurements by which the respective gate is realized. As will be proved in Sec. II F, each gate may be realized only modulo a subsequent byproduct operator U ⌺,g . The byproduct operator is random, but known from the outcomes of the measurements that realize the gate. This knowledge is sufficient to drive the QC C computation deterministically, as we will demonstrate in Sec. II E.
Given a quantum circuit implemented on a cluster C N of qubits, which is divided into two consecutive circuits, suppose that circuit g 1 is implemented on the subcluster C(g 1 ) and the subsequent circuit g 2 is implemented on the subcluster C(g 2 ), such that C N ϭC(g 1 )ഫC(g 2 ). There is an overlap between C(g 1 ) and C(g 2 ), which consists of the output qubits of circuit 1 ͑identical to the input qubits of circuit 2͒, C O (g 1 )ϭC I (g 2 )ϭC(g 1 )പC(g 2 ). The location of the readout quantum register is C O (g 2 )ʚC(g 2 ). Now compare the following two strategies. Strategy ͑i͒ consists of the following steps: ͑1͒ write input and entangle all qubits of C N ; ͑2͒ measure qubits in C N \ C O (g 2 ), to implement the circuit except the readout measurements. Strategy ͑ii͒ consists of steps ͑1͒ write input and entangle the qubits on C(g 1 ); ͑2͒ measure the qubits in C(g 1 )\C O (g 1 ). This implements the first subcircuit and writes the intermediate output to C O (g 1 )ϭC I (g 2 ); ͑3͒ entangle the qubits on C(g 2 ); ͑4͒ measure all qubits in C(g 2 )\C O (g 2 ). Steps 3 and 4 implement the second subcircuit g 2 on the subcluster C(g 2 ). The measurements on C(g 1 )\C O (g 1 ), represented by the projector P 1 commute with the entanglement operation restricted to C(g 2 ), S (C(g 2 )) ϭ:S 2 , P 1 S 2 ϭS 2 P 1 , because these two operations act on different subsets of particles. With P 2 representing the measurements on C(g 2 )\C O (g 2 ) and S 1 ϭS "C(g 1 )… , it follows that S 2 S 1 ϭS (C N ) and P 2 P 1 ϭ P "C N \ C O (g 2 )…8 . Therefore,
Thus, the two strategies are mathematically equivalent. The above argument can be iterated. It follows that entangling the whole cluster once and subsequently performing all the measurements is equivalent to simulating a quantum logic network gate by gate. The exchange of the order of operations is illustrated in Fig. 3. Now, we want to specialize to the case where the quantum input is known and where the quantum output is measured. This is the situation that interests us most in this paper. Examples of such a situation are Shor's factoring algorithm ͓17͔ and Grover's search algorithm ͓18͔. In both cases, the quantum input is ͉ in ͘ϭ iϭ1 n ͉ϩ͘ i . Let us denote the input section of the whole cluster C, comprising the input qubits of the network simulation, as I; and the output section, comprising the qubits of the readout quantum register, as O. As long as the quantum input is known, it is sufficient to consider the state ͉ϩ͘ I ϭ iI ͉ϩ͘ i . For different but known input states ͉ in ͘ I , one can always find a transformation U in such that ͉ in ͘ I ϭU in ͉ϩ͘ I and instead of realizing some unitary transforma-
Preparing an input state ͉ϩ͘ I and entangling it via S (C) with the rest of the cluster C\I is the same as creating a cluster state ͉͘ C on the entire cluster CϭIഫC\I, S (C) ͉ϩ͘ I ͉ϩ͘ C\I ϭS (C) ͉ϩ͘ C ϭ͉͘ C . Therefore, the entire procedure of realizing a quantum computation on the QC C amounts to the following scheme.
Scheme 2. Performing a computation on the QC C .
͑1͒ Prepare a cluster state ͉ ͕͖ ͘ C of sufficient size. ͑2͒ Perform a sequence of measurements on ͉ ͕͖ ͘ C and obtain the result of the computation from all the measurement outcomes.
For practical realization of a QC C computation, Scheme 2 is advantageous over the mathematically equivalent sequence of gate simulations according to Scheme 1. This sequence, in turn, may be used to explain the functioning of the QC C in network terminology.

E. Randomness of the measurement results

We will now show that the described scheme of quantum computation with the QC C works with unit efficiency despite the randomness of the individual measurement results.
First note that a byproduct operator U ⌺ that acts after the final unitary gate U g ͉N͉ does not jeopardize the scheme. Its only effect is that the results of the readout measurements have to be reinterpreted. The byproduct operator U ⌺ that acts upon the logical output qubits 1, . . . ,n has the form
where x i ,z i ͕0,1͖ for 1рiрn. Let the qubits on the cluster, which are left unmeasured, be labeled in the same way as the readout qubits of the quantum logic network. The qubits on the cluster, which take the role of the readout qubits are, at this point, in a state U ⌺ ͉out͘, where ͉out͘ is the output state of the corresponding quantum logic network. The computation is completed by measuring each qubit in the z eigenbasis, thereby obtaining the measurement results ͕s i Ј͖, say. In the QC C scheme, one measures the state U ⌺ ͉out͘ directly, whereby outcomes ͕s i ͖ are obtained and the readout qubits are projected into the state ͉M͘ ϭ͟ iϭ1
Depending on the byproduct operator U ⌺ , the set of measurement results ͕s͖, in general, has a different interpretation from what the network readout ͕s i Ј͖ would have. The measurement basis is the same. From Eq. ͑47͒ one obtains
Here the exchange of the order of the measurements and the entanglement operations is shown. The crosses ''ϫ'' denote the one-qubit measurements and the horizontal lines between adjacent cluster qubits denote the unitary transformations S a,aϩ1 .
From Eq. ͑48͒ we see that a z measurement on the state U ⌺ ͉out͘ with results ͕s͖ represents the same algorithmic output as a z measurement of the state ͉out͘ with the results ͕s i Ј͖, where the sets ͕s͖ and ͕s i Ј͖ are related by

͑49͒

The set ͕s i Ј͖ represents the result of the computation. It can be calculated from the results ͕s i ͖ of the z measurements on the ''readout'' cluster qubits and the values ͕x i ͖ that are determined by the byproduct operator U ⌺ .
Let us now discuss the sequence of the individual gate simulations. Because of Eq. ͑44͒ and the argument presented in Sec. II D, the quantum output ͉ out ͘ of a whole sequence of unitary gates is related to the respective input via
where the gates g i N are labeled corresponding to the order of their action.
Thus, we find that one can cope with the randomness of the measurement results provided the byproduct operators U ⌺,g i in Eq. ͑50͒ can be propagated forward through the subsequent gates such that they act on the cluster qubits representing the output register. This can be done. To propagate the byproduct operators we use the propagation relations
for the CNOT gate,
for general rotations U Rot ͓,,͔ as defined in Eq. ͑24͒, and
for the Hadamard and /2-phase gates propagation relations ͑52͒ apply to general rotations realized via Procedure 2-including the Hadamard and /2-phase gates-while the propagation relations ͑53͒ apply to the Hadamard and /2-phase gates as realized via Procedure 3.
Note that propagation relations ͑51͒-͑53͒ are such that the Pauli operators are mapped onto the Pauli operators under propagation and thus the byproduct operators remain in the Pauli group when being propagated. Further note that there is a difference between the relations for propagation through gates that are in the Clifford group and through those that are not. For CNOT, the Hadamard, and the /2-phase gates, the byproduct operator changes under propagation, while the gate remains unchanged. This holds for all gates in the Clifford group because the propagation relations for the Clifford gates are of the form U g U ⌺ ϭ(U g U ⌺ U g Ϫ1 )U g as Eqs. ͑51͒ and ͑53͒, i.e., the byproduct operator U ⌺ is conjugated under the gate, and the Clifford group by its definition as the normalizer of the Pauli group maps the Pauli operators onto Pauli operators under conjugation. Propagation relations ͑51͒ and ͑53͒ are identical to the propagation relations for Pauli errors given in Ref. ͓19͔. For the gates that are not in the Clifford group, conjugation of the byproduct operator under the gate would, in general, not work and therefore, for the rotations that are not in the Clifford group, the propagation relations are different. There, the gate is conjugated under the byproduct operator, and thus the byproduct operator remains unchanged in propagation while the gate is modified. In both cases, the forward propagation leaves the byproduct operators in the Pauli group. In particular, their tensor product structure is maintained.
Let us now discuss how byproduct operator propagation affects the scheme of computation with the QC C . Using the above propagation relations, Eq. ͑50͒ can be rewritten in the following way:
Therein, U ⌺,g i ͉ ⍀ are forward propagated byproduct operators, resulting from the byproduct operators U ⌺,g i of the gates g i . They accumulate to the total byproduct operator U ⌺ whose effect on the result of the computation is contained in Eq. ͑49͒,
Further, U g i Ј are the gates modified under the propagation of the byproduct operators. As discussed above, for gates in the Clifford group we have
as can be seen from Eqs. ͑51͒ and ͑53͒.
The gates that are not in the Clifford group are modified by byproduct operator propagation. Specifically, general rotations ͑24͒ are conjugated, as can be seen from Eq. ͑52͒. From the structure of Eq. ͑50͒ we see that only the byproduct operators of gates g k earlier than g i in the network may have an effect on U g i , i.e., those with kϽi. To give an explicit expression, let us define U ⌺,g k ͉ O i , which are byproduct operators U ⌺,g k propagated forward by propagation relations ͑51͒-͑53͒ to the vertical cut O i through the network, see Fig.  4. A vertical cut through a network is a cut that intersects each qubit line exactly once and does not intersect gates. The vertical cut O i has the additional property that it intersects the network just before the input of gate g i . The relation between a rotation U g i Ј modified by the byproduct operators and the nonmodified rotation U g i is
Now that we have investigated the effect of byproduct operator propagation on the individual gates let us return to Eq. ͑54͒. There, we find that the operations that act on the input state ͉ in ͘ group into two factors. The first is composed of the modified gate operations U g i Ј and the second is composed of the forward propagated byproduct operators. The second factor gives the accumulated byproduct operator U ⌺ and is absorbed into the result of the computation via Eq.

͑49͒. It does not cause any complication.

So what remains is the first factor, and we find that the unitary evolution of the input state ͉ in ͘ that is realized is composed of the modified gates U g i Ј . The gates we will realize are thus U g i Ј , not U g i . However, the standard procedures ͑Procedures 1-3͒ in Sec. II B are for the operations U g i . Thus, we have to read Eq. ͑57͒ in reverse. We need to deduce U g i from U g i Ј . Once the gates g k for all kϽi have been realized, this can be done for each gate g i since the byproduct operators U ⌺,k are then known for all kϽi. Finally, with U g i determined from U g i Ј , Procedure 2 gives the measurement bases required for the realization of the gate g i . Note that it is a sufficient criterion for the realization of the gate g i that all gates g k with kϽi must have been realized before, but not a necessary one. Let us, at this point, address the question of temporal ordering more explicitly. For proper discussion of the temporal ordering we have to step out of the network frame for a moment. First, note that in the case of the QC C the basic primitive are measurements. Thus, the temporal complexity will be determined by the temporal ordering of these measurements, unlike in quantum logic networks, where it depends on the ordering of gates. The most efficient ordering of measurements that simulates a quantum logic network is not predescribed by the temporal ordering of the gates in this network.
A temporal ordering among the measurements is inferred from the requirement to keep the computation on the QC C deterministic in spite of the randomness introduced by the measurements. This randomness is accounted for by the byproduct operators. The key to obtain the temporal ordering of measurements is Eq. ͑57͒. There, the byproduct operators U ⌺,g k ͉ O i may modify Euler angles of the one-qubit rotations in the network and, consequently, change measurement bases. The temporal ordering thus arises due to the fact that bases for one-qubit measurements must be chosen in accordance with outcomes obtained from the measurements of other qubits.
For each cluster qubit q that needs to be measured in a nontrivial basis, i.e., not in the eigenbasis of x , y , or z , a set of cluster qubits p i can be identified, whose measurement outcomes influence the choice of the measurement basis for qubit q. We say that q is in the forward cone ͓7͔ of p i , qFC(p i ). Each cluster qubit has a forward cone, and in no forward cone there appears a qubit that is measured in a trivial basis.
The rule is that a cluster qubit q can only be measured once all cluster qubits p i for which qfc(p i ) have been measured earlier. The forward cones thereby generate an antireflexive partial ordering among the measurements from which the most efficient measurement strategy can be inferred; see Ref. ͓7͔. Gates in the Clifford group do not contribute to the temporal complexity of a QC C algorithm, see Sec. II I.

F. Using quantum correlations for quantum computation

In this section we give a criterion that allows us to demonstrate the functioning of the QC C simulations of unitary gates in a compact way. Specifically, Theorem 1 given below establishes a correspondence between general quantum gates and quantum correlations of states. Using this correspondence, the explanation of QC C gates can be reduced to stabilizer manipulations.
Before we state the theorem, let us make the notion of a measurement pattern more precise. In a QC C computation one can only choose the measurement bases, while the measurement outcomes are random. This is sufficient for deterministic computation. Thus, one can perform measurements specified by a spatial and temporal pattern of measurement bases, but one cannot control into which of the two eigenstates the qubits are projected.
Definition 1. A measurement pattern M (C) on a cluster C is a set of vectors
defining the measurement bases of the one-qubit measurements on C.
FIG. 4. Vertical cuts. The vertical cuts intersect each qubit line exactly once, but do not intersect gates. Thus, O i , O j , and ⍀ are vertical cuts, but O " is not. The cut O i intersects the rotation U x just before its input. For two of the rotations in the displayed network, the subclusters on which these gates are realized are symbolically displayed in gray underlay. Via the measurement of the cluster qubits a and b ͑displayed as black dots with white border͒, the rotation angles of the respective rotations U x and U z are set.
If this pattern M (C) of measurements is applied on an initial state ͉⌿ E ͘ C and thereby the set of measurement outcomes ͕s͖ C ϭ͕s a ͕0,1͖͉aC͖ ͑59͒ is obtained, then the resulting state ͉⌿ M ͘ C is, modulo norm factor, given by
Additionally, let us introduce some conventions for labeling. Let C I (g) and C O (g) be such that ͉C I (g)͉ϭ͉C O (g)͉ ϭn, where n is the number of logical qubits processed by g. Operators acting on qubits pC I (g) and qC O (g) are labeled by upper indices (C I (g),i) and (C O (g),iЈ), 1рi,iЈ рn, respectively. The qubits pC I (g) and qC O (g) are ordered from 1 to n in the same way as the logical qubits that they represent.
We make a distinction between the gate g and the unitary transformation U it realizes. The gate gN does, besides specifying the unitary transformation U, also comprise the information about the location of the gate within the network.
After these definitions and conventions we can now state the following theorem.
ϭл be a cluster for the simulation of a gate g, realizing the unitary transformation U, and ͉͘ C(g) the cluster state on the cluster C(g).
Then, on the cluster C(g) the gate g acting on an arbitrary quantum input state ͉ in ͘ can be realized according to Scheme 1 with the measurement directions in C M (g) described by M "C M (g)… and the measurements of the qubits in C I (g) being x measurements. Thereby, the input and output state in the simulation of g are related via
where U ⌺ is a byproduct operator given by
The significance of the above theorem is that it provides a comparably simple criterion for the functioning of gate simulations on the QC C . We can now base the explanation of the gates directly on eigenvalue equations ͑1͒, which were also used to define the cluster states in a compact way. The quan-tum correlations required to explain the functioning of the gates are derived from the basic correlations ͑2͒ rather easily, and thus the use of Theorem 1 makes the explanation of the gates more transparent and compact.
In the simulation of an individual quantum gate according to Scheme 1, after reading of the input state and the entangling operation S "C(g)… , but before the measurements that realize the gates are performed, the resulting state carries the quantum input in an encoded form. This state is, in general, not a cluster state. It is therefore not clear a priori that cluster state correlations alone are sufficient to explain the functioning of the gate. However, this is what Theorem 1 states. To prove the functioning of a gate g on the QC C it is sufficient to demonstrate that a cluster state on C(g) exhibits certain quantum correlations.
Before we turn to the proof of Theorem 1 let us note that the measurements described by P ͕s͖
"M(g)…, as they have full rank, project the initial cluster state ͉͘ C(g) into a tensor product state,
Thereof only the second factor, ͉͘ C I (g)ഫC O (g) , is of interest. This state alone satisfies eigenvalue equations ͑61͒ and is uniquely determined by these equations. To see this, consider the state ͉Ј͘ C I(g)ഫC O(g) ϭU † ͉͘ C I(g)ഫC O(g) . It satisfies the 2n eigenvalue equations
where we have written in short ͉Ј͘ for ͉Ј͘ C I (g)ഫC O (g) . The state ͉Ј͘ C I (g)ഫC O (g) is uniquely defined by the above set of commuting observables, it is a product of the Bell states. Therefore, ͉͘ C I (g)ഫC O (g) is uniquely defined as well.
Proof of Theorem 1. We will discuss the functioning of the gates for two cases of inputs. First, for all input states in the computational basis. This leaves relative phases open, which have to be determined. Second, to fix them, we discuss the input state with all qubits individually in ͉ϩ͘. As we will see, from these two cases it can be concluded that the gate simulation works for all input states of the computational basis. This is sufficient because of the linearity of the applied operations; if the gate simulations work for states of the computational basis, then they work for superpositions of such inputs as well.
. . ,n. Then the state ͉⌿ out (z)͘ C(g) of the qubits in C ͓after performing a procedure according to Scheme 1, using a measurement pattern M "C M (g)… on the body C M (g) of the gate g, and applying x measurements on C I (g)] is
with norm factors n O (z) that are nonzero for all z, as we shall show later.
The input ͉z͘ in Eq. ͑65͒ satisfies the equation
͔/2, and n I (z)ϭ1/2 n/2 for all z. Now note that S "C(g)… and P Z,z "C I (g)… , as well as P ͕s͖
(M) and P Z,z "C I (g)… , commute. Thus, ͉⌿ out (z)͘ C(g) can be written as
where ͉͘ C(g) is specified by eigenvalue equations ͑61͒ in Theorem 1.
Let us, at this point, emphasize that the projections P ͕s͖ "C I (g)… (X) and P Z,z "C I (g)… in Eq. ͑67͒ are of very different origin. The projector P ͕s͖ "C I (g)… (X) describes the action of the x measurements on the qubits in C I (g). These measurements are part of the procedure to realize some gate g on the cluster C(g). One has no control over the thereby obtained measurement outcomes ͕s͖ specifying P ͕s͖ "C I (g)… (X). In contrast, the projector P Z,z "C I (g)… does not correspond to measurements that are performed in reality. Instead, it is introduced as an auxiliary construction that allows one to relate the processing of quantum inputs to quantum correlations in cluster states. The parameters z specifying the quantum input ͉z͘ and thus the projector P Z,z "C I (g)… in Eq. ͑66͒ can be chosen freely. The goal is to find for the state ͉⌿ out (z)͘ C(g) an expression involving the transformation U acting on the input ͉z͘. To accomplish this, first observe that for the state on the rhs of Eq. ͑67͒ via Eq. ͑61͒, the following eigenvalue equations hold:
with iϭ1, . . . ,n.
To make use of Eqs. ͑68͒ we need to prove that P ͕s͖
͉͘ C(g) 0 for all z under the assumptions of Theorem 1.
For this, we consider the scalar C(g) ͉͗P Z,z "C I (g)… ͉͘ C(g) and write P Z,z "C I (g)… in the form
where I k ʚC I л᭙kϭ1, . . . ,2 n . For each I k we choose an iI k and insert the respective eigenvalue equation from the upper line of Eq. ͑61͒ into C(g) ͉͗ jI k z ( j) ͉͘ C(g) . Since
͉͘ C(g) ϭ1/2 n , such that P Z,z "C I (g)… ͉͘ C(g) 0 and therefore also P ͕s͖
or, in other words, n O Ј (z) 0 for all z.
Due to the fact that the projections P Z,z "C I (g)… and P ͕s͖ "C M (g)… (M) are of full rank the above state has the form P ͕s͖

͑71͒

where ͉s͘ x,C I ϭ
Elaborating the argument that leads to Eq. ͑70͒ one finds that n O Ј (z)ϭ1/2 n and n O (z)ϭ1/2 n/2 , but at this point the precise values of the normalization factors are not important as long as they are nonzero.
In Eq. ͑71͒ only the third factor of the state on the rhs is interesting, and this factor is determined by eigenvalue equations ͑68͒:
where U ⌺ is given by Eq. ͑63͒. Now, because of Eq. ͑67͒
with n O Ј (z) 0 ᭙ z, a solution ͑71͒ with Eq. ͑72͒ for the state P ͕s͖
is also a solution for the state ͉⌿ out (z)͘ C(g) , and one finally obtains
There appear no additional norm factors in Eq. ͑73͒ because the states on the left-hand side ͑lhs͒ and the rhs are both normalized to unity. Solution ͑73͒ still allows for one free parameter, the phase factor e i (z) . Note that, a priori, the phase factors for different z can all be different.
This concludes the discussion of Case 1. We have found in Eq. ͑73͒ that the realized gate acts as
where the gate D is diagonal in the computational basis and contains all the phases e i (z) . What remains is to show that Dϭ1 modulo a possible global phase. Case 2. Now the same procedure is applied for the input state ͉ in ͘ϭ͉ϩ͘ª iϭ1 n ͉ϩ͘ i . Then, the state ͉⌿ out (ϩ)͘ C(g) that results from the gate simulation is
with a nonzero norm factor n O (ϩ). Using the upper line of eigenvalue equations ͑61͒, the state ͉⌿ out (ϩ)͘ C(g) is found to obey the eigenvalue equations
Eigenvalue equations ͑76͒ in combination with Eq. ͑75͒ imply that
with being a free parameter. Therefore, on the input state ͉ϩ͘ the gate simulation acts as
This observation concludes the discussion of Case 2. The fact that Eqs. ͑73͒ and ͑77͒ hold simultaneously imposes stringent conditions on the phases (z). To see this, let us evaluate the scalar product

͑79͒

From Eq. ͑77͒ it follows immediately that
On the other hand, since ͉ϩ͘ϭ1/2 n/2 ͚ z͕0,1͖ n͉ z͘ and, by linearity, ͉⌿ out (ϩ)͘ϭ1/2 n/2 ͚ z͕0,1͖ n͉ ⌿ out (z)͘, from Eq. ͑73͒ it follows that c ϭ 1 2 n ͚ z͕0,1͖ n e Ϫi(z) . ͑81͒
The sum in Eq. ͑81͒ runs over 2 n terms. Thus, with ͉e Ϫi(z) ͉ϭ1 for all z, it follows from the triangle inequality that ͉c ͉р1. The modulus of c can be unity only if all e Ϫi(z) are equal. As Eq. ͑80͒ shows, ͉c ͉ is indeed equal to unity. Therefore, the phase factors e i(z) must all be the same, and with Eqs. ͑80͒ and ͑81͒,
If we now insert Eq. ͑82͒ into Eq. ͑73͒, we find that the gate simulation acts upon every input state in the computational basis, and thus upon every input state, as Ũ g ϭe i U U ⌺ . Therein, the global phase factor e i has no effect. Thus, we find that the gate simulation indeed acts as stated in Eqs. ͑62͒ and ͑63͒. ᮀ We would like to acknowledge that a similar theorem restricted to gates in the Clifford group has been obtained in Ref. ͓20͔.
Let us conclude this section with some comments on how to use this theorem. First, note that Theorem 1 does not imply anything about the temporal order of measurements within a gate simulation. In particular, it should be understood that it does not imply that first the measurements on the cluster qubits in C M (g) and thereafter the measurements in C I (g) are performed.
Instead, first, all those cluster qubits qC I (g)ഫC M (g) are measured whose measurement basis is the eigenbasis of either x or y ͑remember that, after the removal of the redundant cluster qubits, as described in Sec. II C, we are dealing with clusters C N such that, apart from the readout, no measurements in the z eigenbasis occur͒. Second, possibly in several subsequent rounds, the remaining measurements are performed in bases that are chosen according to previous measurement results.
In subsequent sections we will illustrate in a number of examples how Theorem 1 is used to demonstrate the functioning of quantum gate simulations on the QC C , and how the strategies for adapting the measurement bases are foun.

G. Function of the CNOT gate and general one-qubit rotations

In this section, we demonstrate that the measurement patterns that we have introduced do indeed realize the desired quantum logic gates.
The basis for all our considerations is set ͑1͒ of eigenvalue equations fulfilled by the cluster states. Therefore, let us, before we turn to the realization of the gates in the universal set, describe how the eigenvalue equations can be manipulated. Equations ͑1͒ are not the only eigenvalue equations satisfied by the cluster state. Instead, a vast number of other eigenvalue equations can be derived from them.
The operators K (a) may, for example, be added, multiplied by a scalar, and multiplied with each other. In this way, a large number of eigenvalue equations can be generated from Eqs. ͑1͒. Note, however, that not all operators generated in this way are correlation operators. Non-Hermitian operators can be generated, which do not represent observables, yet will prove to be useful for the construction of new correlation operators.
Furthermore, if quantum correlation operator K for state ͉͘ commutes with measured observable r ជ i • ជ (i) , the correlation will still apply to the measured state. More specifically, if the state ͉͘ satisfies the eigenvalue equation K͉͘ϭ͉͘ and ͓K,r ជ i • ជ ͔ϭ0, then the state resulting from the measurement, To demonstrate and explain the measurement patterns realizing certain quantum gates, the program is as follows. First, from the set of eigenvalue equations that define the cluster state ͉͘ C(g) , we derive a set of eigenvalue equations, which is compatible with the measurement pattern on C M . Then, we use these to deduce the set of eigenvalue equations that define the state ͉͘ C(g) , where the qubits in C M have been measured. Thus, we demonstrate that the assumptions for Theorem 1, that is the set of Eqs. ͑61͒, are satisfied with the appropriate unitary transformation U. Third, U ⌺ is obtained from Eq. ͑63͒ as a function of the measurement results. The order of U and U ⌺ is then interchanged and, in this way, the temporal ordering of the measurements becomes apparent.

Identity gate

As a simple example, let us first consider a gate, which realizes the identity operation 1 on a single logical qubit.
For the identity gates C I , C M , and C O , each consists of a single qubit, so labeling the qubits 1, 2 and 3, 1C I , 2 C M , and 3C O . The pattern M(1) corresponds to a measurement of qubit 2 in the x basis.
Let ͉͘ C(1) be the cluster state on these three qubits. The state is defined by the following set of eigenvalue equations.
Using the stabilizer formalism ͓10͔ one obtains that after the measurement of qubit 2 in the eigenbasis of x with outcome s 2 , the resulting state of the cluster, ͉͘ C(1) , obeys the eigenvalue equations
Now, since qubits 1 and 3 represent the input and output qubits, respectively, the assumption of Theorem 1, Eq. ͑61͒, is satisfied for Uϭ1. The byproduct operator U ⌺ is obtained from Eq. ͑63͒, and we find that the full unitary operation realized by the gate is Ũ ϭ1 x s 2 z s 1 ϭ x s 2 z s 1 1.
Also note that a wire with length one (C I (H)ϭ1, C M (H)ϭл, C O (H)ϭ2), i.e., half of the above elementary wire, implements a Hadamard transformation. As in this construction the input and output qubits lie on different sublattices of C, one on the even and one on the odd sublattice, we do not use it in the universal set of gates. Nevertheless, this realization of the Hadamard transformation can be a useful tool in gate construction. For example, we will use it in Sec. II G 4 to construct the realization of the z rotations out of the realization of x rotations.

Removing unnecessary measurements

In larger measurement patterns, whenever pairs of adjacent x -qubits in a wire are surrounded above and below by either vacant lattice sites or z measurements, they can be removed from the pattern without changing the logical operation of the gate. This is simple to show in the case of a linear cluster. Consider six qubits, labeled a to f, which are part of a longer line of qubits, prepared in a cluster state. Four of the eigenvalue equations that define the state are
Suppose, a measurement pattern M on these qubits contains measurements of the observable x on qubits c and d. Measurements in the x basis can be made before any other measurements in M. If these two measurements alone are carried out, the new state fulfills the following eigenvalue equations, derived from Eq. ͑86͒ in the usual way,
The resulting state is therefore a cluster state from which qubits c and d have been removed, and b and e play the role of adjacent qubits. Thus, the two measurements have mapped a cluster state onto a cluster state and thus do not contribute to the logical operation realized by M, which, in the case where both s c and s d equal 0, is completely equivalent to the reduced measurement pattern MЈ, from which these adjacent x measurements have been removed.

One-qubit rotation around x axis

A one-qubit rotation through an angle ␣ about the x axis, U x ͓␣͔ϭexp͓Ϫi␣/2 x ͔, is realized on the same three qubit layout as the identity gate. Labeling the qubits 1, 2, and 3, as in the preceding section, 1ϭC I , 2ϭC M , and 3ϭC O . The measurement pattern M(U x ) consists of a measurement, on qubit 2, of the observable represented by the vector r ជ xy () ϭ"cos(),sin(),0…, r ជ xy ͑ ͒• ជ ϭcos x ϩsin y ϭU z ͓͔ x U z ͓Ϫ͔, ͑88͒ whose eigenstates lie in the x-y plane of the Bloch sphere at an angle of to the x axis.
The cluster state ͉͘ C(U x ) is defined by Eqs. ͑83͒. After the measurement of M(U x ), the resulting state is
To generate an eigenvalue equation whose operator commutes with r ជ xy ()• ជ , we manipulate Eq. ͑83c͒ in the following way:
i.e.,
where the last equation is true for all ͓0,2͔. This takes a more useful form, if we write it in terms of one-qubit rotations,
We use this, and the equation
to construct the subsequent eigenvalue equation. Let us denote the operator on the lhs of eigenvalue equation ͑91͒ as A, and the operator on the lhs of Eq. ͑92͒ as B. With Eqs. ͑91͒ and ͑92͒ it follows that ABA Ϫ1 ͉͘ C(U x ) ϭ͉͘ C(U x ) , i.e.,
Note that the operators A and B do not commute. Applying P xy(),2 to both sides, we obtain the following eigenvalue equation for ͉͘ C(U x ) :

͑94͒

In the same way as for the identity gate we also apply the projector to an eigenvalue equation generated from Eqs. ͑83a͒ and ͑83c͒ to obtain
and thus we see that Eq. ͑61͒ is satisfied for UϭU x ͓Ϫ͔ and U ⌺ ϭ z s 1 x s 2 . Interchanging the order of these operators is not as trivial here as for the identity gate. When z is propagated through U x ͓͔, the sign of the angle is reversed, so we find that the gate operation realized by this M(U x ) in the QC C is
The sign of the rotation realized by this gate is a function of s 1 , the outcome of the measurement on qubit 1. This is an example of the temporal ordering of measurements in the QC C . In order to realize U x ͓␣͔ deterministically, the angle of the measurement, , on qubit 2 must be ϭ(Ϫ1) s 1 (Ϫ␣), thus this measurement can only be realized after the measurement of qubit 1.

Rotation around z axis

The measurement pattern for a rotation around the z axis U z ͓␤͔ϭexp͓Ϫi␤/2 z ͔ is illustrated in Fig. 2. It requires five qubits for its realization.
The measurement layout M(U z ) is similar to the rotation about the x axis, except for two additional x measurements on either side of the central qubit. The simplest way to understand this gate is to regard it as the concatenation U z ͓␣͔ϭH U x ͓␣͔H. The Hadamard transformations may be realized as wires of length one, see Sec. II G 1. Thus, the measurement pattern of the z rotation is that of the x rotation plus one cluster qubit on either side measured in the eigenbasis of x , as displayed in Fig. 5.
The explanation in terms of eigenvalue equations obeyed by cluster states is as follows. Let us label the qubits 1-5. The cluster state ͉͘ C(U z ) is defined by eigenvalue equations of the usual form. If qubits 2 and 4 are measured in the x basis, the resulting state ͉Ј͘ C(U z ) ϭ P x,s 2 (2) P x,s 4 (4) ͉͘ C(U z ) fulfills the following set of eigenvalue equations:
This set of equations is analogous to Eqs. ͑83͒, except for the different eigenvalues and that the input and output qubits x and z bases have been exchanged. From here on the analysis of the measurement pattern runs parallel to the preceding section.
One finds M(U z ) realizes the operation U z (␤) if the basis of the measurement on qubit 3 is chosen to be the eigenbasis of r ជ xy "(Ϫ1) s 2 (Ϫ␤)…• ជ , where r ជ xy () is defined in Eq. ͑88͒. Qubit 2 must thus be measured prior to qubit 3. The byproduct operator for this gate is U ⌺,U z ϭ x s 2 ϩs 4 z s 1 ϩs 3 .

Arbitrary rotation

The arbitrary Euler rotation can be realized by combining the measurement patterns of rotations around x and z axes by overlaying input and output qubits of adjacent patterns, as described in Sec. II D. This creates a measurement pattern of seven qubits plus input and output qubits, labeled as in Fig.  6, with measurements of x on qubits 3, 4, 6, and 7, and measurements in the x-y plane at angles ␣, ␤, and ␥ on qubits 2, 5, and 8, respectively.
The unitary operation realized by these connected measurement patterns is FIG. 5. Useful identity for the realization of the rotation U z ͓␣͔ as the sequence H U x ͓␣͔H.
FIG. 6. General rotation composed of two x rotations and a z rotation in between ͑Euler representation͒. In the QC C realization pairs of adjacent cluster qubits measured in the x eigenbasis may be removed from the measurement pattern.
As we have shown above, adjacent pairs of x measurements can be removed from the pattern without changing the operation realized by the gate. The operation realized by this reduced measurement pattern is obtained by setting the measurement results from the removed qubits to 0, s 3 ,s 4 ,s 6 ,s 7 ϭ0. After relabelling the remaining qubits in the measurement patterns 1-5, we obtain
Propagating all byproduct operators to the left-hand side, we find that the unitary operation realized by the measurement pattern is
with byproduct operator U ⌺ ϭ x s 2 ϩs 4 z s 1 ϩs 3 . One finds that, to realize a specific rotation U Rot ͓,,͔ ϭU x ͓͔U z ͓͔U x ͓͔, the angles ␣, ␤, ␥ specifying the measurement bases of the qubits 2, 3, and 4 are again dependent on the measurement results of other qubits. We see that ␣ϭ(Ϫ1) s 1 (Ϫ), ␤ϭ(Ϫ1) s 2 (Ϫ), ␥ϭ(Ϫ1) s 1 ϩs 3 (Ϫ).
To realize a specific rotation deterministically, qubit 2 must thus be measured before qubits 3 and 4, and qubit 3 before qubit 4, in the bases specified in Sec. II B.

Hadamard and Õ2-phase gates

The Hadamard and the /2-phase gates have the property that under conjugation with these gates Pauli operators are mapped onto Pauli operators,
from which propagation relations ͑53͒ follow. Related to this property is the fact that these two special rotations may be realized via x and y measurements. Such measurement bases need not be adapted to previously obtained measurement results and, therefore, while these rotations might be realized in the same way as any other rotation, there is a more advantageous way to do so.
To realize either of the gates we use again a cluster state of five qubits in a chain C(H). Let the labeling of the qubits be as in Figs. 2͑d͒ and 2͑e͒, i.e., qubit 1 is the input and qubit 5 is the output qubit.
A cluster state ͉͘ C(H) obeys the two eigenvalue equations
When qubits 2, 3, and 4 of this state are measured in the y eigenbasis and thereby the measurement outcomes s 2 , s 3 , s 4 ͕0,1͖ are obtained, the resulting state ͉͘ C(H) obeys the eigenvalue equations
From Eq. ͑101͒ we see that correlations ͑104͒ are precisely those we need to explain the realization of the Hadamard gate. Using Theorem 1 we find that by Procedure 3 with measurement of the operators x (1) , y (2) , y (3) , and y (4) a Hadamard gate with a byproduct operator, as given in Eq. ͑30͒, is realized.
Considering the rotation U z ͓/2͔, a cluster state ͉͘ C(U z [/2]) of a chain of five qubits obeys the eigenvalue equations
When qubits 2 and 4 of this state are measured in the x eigenbasis and qubit 3 is measured in the y eigenbasis, with the measurement outcomes s 2 , s 3 , s 4 ͕0,1͖ obtained, the resulting state ͉͘ C(U z [/2]) obeys the eigenvalue equations
Using Theorem 1 we find that by Procedure 3 with measurement of the operators x (1) , x (2) , y
, and x (4) a /2-phase gate is realized, where the byproduct operator is given by Eq. ͑30͒.

The CNOT gate

A measurement pattern that realizes a CNOT gate is illustrated in Fig. 2. Labeling the qubits as in Fig. 2, we use the same analysis as above to show that this measurement pattern does indeed realize a CNOT gate in the QC C .
Of the cluster C(CNOT) on which the gate is realized, qubits 1 and 9 belong to C I , qubits 7 and 15 belong to C O and the remaining qubits belong to C M . Let ͉͘ be a cluster state on C(CNOT), which obeys the set of eigenvalue equations ͑1͒.
From these basic eigenvalue equations there follow the equations
Subsequently, we will often use a graphic representation of eigenvalue equations such as ͑107a͒-͑107d͒. Each of these equations is specified by the set of correlation centers q for which the basic correlation operators K (q) ͑2͒ enter the rhs of the equation. While the information content is the same, it is often more illustrative to display the pattern of correlation centers than to write down the corresponding cluster state eigenvalue equation. As an example, the pattern of correlation centers, which represents the eigenvalue equation ͑107a͒ is given in Fig. 7. If the qubits 10, 11, 13, and 14 are measured in the x eigenbasis and the qubits 2, 3, 4, 5, 6, 8, and 12 are measured in the y eigenbasis, whereby the measurement results s 2 -s 6 , s 8 , s 10 -s 14 are obtained, then the cluster state eigenvalue equations ͑107a͒-͑107d͒ induce the following eigenvalue equations for the projected state ͉͘:
x (1) x (7) x (15) ͉͘ϭ͑Ϫ1 ͒ 1ϩs 3 ϩs 4 ϩs 5 ϩs 8 ϩs 13 ͉͘, ͑108a͒ z (1) z (7) ͉͘ϭ͑Ϫ1 ͒ s 2 ϩs 3 ϩs 5 ϩs 6 ͉͘, ͑108b͒
x (9) x (15) ͉͘ϭ͑Ϫ1 ͒ s 11 ϩs 13 ͉͘, ͑108c͒ z (9) z (7) z (15) ͉͘ϭ͑Ϫ1 ͒ s 5 ϩs 6 ϩs 8 ϩs 10 ϩs 12 ϩs 14 ͉͘. ͑108d͒
Therein, qubits 1 and 7 represent the input and output for the control qubit and qubits 9 and 15 represent the input and output for the target qubit. Writing the CNOT unitary operation on control and target qubits CNOT( c,t), we find
Comparing these equations to eigenvalue equations ͑108a͒-͑108d͒, one sees that M does indeed realize a CNOT gate. Furthermore, after reading off the operator U ⌺ using Eqs. ͑61͒ and ͑63͒ and propagating the byproduct operators through the output side of the CNOT gate, one finds the expressions for the byproduct operators, reported in Eq. ͑23͒.

H. Upper bounds on resource consumption

Here we discuss the spatial, temporal, and operational resources required for the QC C and compare with resource requirements of a network quantum computer.
To run a specific quantum algorithm, the QC C requires a cluster of a certain size. Therefore, the QC C -spatial resources S are the number of cluster qubits in the required cluster state ͉͘ C , i.e., Sϭ͉C͉. The computation is driven by one-qubit measurement only. Thus, a single one-qubit measurement is one unit of operational resources, and the QC C -operational resources O are defined as the total number of one-qubit measurements involved. The operational resources O are always smaller or equal to the spatial resources S,

OрS, ͑110͒

since each cluster qubit is measured at most once. As for the temporal resources, the QC C -logical depth T is the minimum number of measurement rounds to which the measurements can be parallelized. Let us briefly recall the definition of these resources in the network model. The temporal resources are specified by the network logical depth T qln , which is the minimal number of steps to which quantum gates and readout measurements can be parallelized. The spatial resources S qln count the number of logical qubits on which an algorithm runs. Finally, the operational resources O qln are the number of elementary operations required to carry out an algorithm, i.e., the number of gates and measurements.
The construction kit for the simulation of quantum logic networks on the QC C shall contain a universal set of gates, in our case the CNOT gate between arbitrary qubits and the one qubit rotations. Already the next-neighbor CNOT with general rotations is universal since a general CNOT can be assembled of a next-neighbor CNOT and swap gates, which can themselves be composed of next-neighbor CNOTs. However, in the following we would like to use for the general CNOT the less cumbersome construction described in Sec. IV B. For this gate, the distance between logical qubits, i.e., between paral- lel qubit wires, is 4. The virtue of this gate is that it can always be realized on a vertical slice of width 6 on the cluster, no matter how far control and target qubit are separated. A slice of width 6 means that the distance between an input qubit of the gate and the corresponding input of the consecutive gate is six lattice spacings. This general CNOT gate determines the spatial dimensions of a unit cell in the measurement patterns. The size of this unit cell is 4ϫ6. The other elementary gates, the next-neighbor CNOT and the rotations are smaller than a unit cell and therefore have to be stretched. This is easily accomplished. The next-neighbor CNOT, as displayed in Fig. 2͑a͒ has a size of 2ϫ6 and is extended to size 4ϫ6 by inserting two adjacent cluster qubits into the vertical bridge connecting the horizontal qubit lines. The general rotation as in Fig. 2͑b͒ has width 4 and is stretched to width 6 by inserting two cluster qubits just before the output.
Concerning the temporal resources we first observe that we can realize the gates in the same temporal order as in the network model. To realize a general CNOT on the QC C takes one step of measurements, to realize a general rotation takes at most three. For the network model we do not assume that a general rotation has to be Euler-decomposed. Rather we assume that in the network model a rotation can be realized in a single step. Thus, the temporal resources of the QC C and in the network model are related via
As for the spatial resources, let us consider a rectangular cluster of height h and width w on which the qubit wires are oriented horizontally, with the network register state propagating from left to right. As the logical qubits have distance 4, the height of the cluster has to be hϭ4S qln Ϫ3, where S qln is equal to the number n of logical qubits. Further, the number of gates in the circuit is at most S qln T qln because, in the network model, in each step at most S qln gates can be realized. On each vertical slice of width 6 on the cluster there fits at least one gate such that-taking into account an extra slice of width 1 for the readout cluster qubits-for the width holds wр6S qln T qln ϩ1. With Sϭh w one finds that
In a similar way, a bound involving the network operational resources can be obtained. The spatial overhead S and the operational overhead O per elementary network operation is р24S qln if this operation is a unitary gate from the universal set described before, and is equal to 1 if this operation is a readout measurement. Thus, we also have Sр24O qln S qln ,
The purpose of this section was to demonstrate that the scaling of spatial and temporal resources is at worst polynomial as compared to the network model. In Ref. ͓7͔ it has been shown, as stated in Sec. III A, that the required classical processing increases the computation time only marginally ͑logarithmically in the number n of logical qubits͒, and thus there is no exponential overhead in either classical or quantum resources.
The upper bounds in Eqs. ͑111͒-͑113͒ should not be taken for estimates. For algorithms of practical interest the required resources usually scale much more favorably and there do not even have to be overheads at all. This is illustrated for the temporal complexity of Clifford circuits in Sec. II I and in the examples of Sec. IV. A spatial overhead always exists. However, this is compensated by the fact that the operational effort to create a cluster state is independent of the cluster size.

I. Quantum circuits in the Clifford group can be realized in a single step

The measurement bases to realize the Hadamard and the /2-phase gates need not be adapted since only operators x and y are measured. The same holds for the realization of the CNOT gate, see Fig. 2. Thus, all the Hadamard, /2-phase, and CNOT gates of a quantum circuit can be realized simultaneously in the first measurement round, regardless of their location in the network. In particular, quantum circuits that consist only of such gates, i.e., circuits in the Clifford group, can be realized in a single time step. As an example, many circuits for coding and decoding are in the Clifford group.
The fact that quantum circuits in the Clifford group can be realized in a single time step has previously not been known for networks. The best upper bound on the logical depth that was known previously scales logarithmically with the number of logical qubits ͓21͔.
Note that, as stated by the Gottesman-Knill theorem ͓22͔, there is no need for fast Clifford circuits if the quantum output is measured in a Pauli basis because these circuits can be simulated efficiently classically. However, the purpose of this section is to point out that the whole Clifford part of any quantum circuit can be performed in a single time step. We will discuss this point further in Sec. III B.
Here we find a first aspect of QC C computation, which is not adequately described within the network model, and with this observation we conclude the discussion of the QC C as a simulator of quantum logic networks.

III. COMPUTATIONAL MODEL UNDERLYING THE QC C


A. Processing of information

In the network model of quantum computation one usually regards a quantum register as the carrier of information. The quantum register is prepared in some input state and processed to some output state by applying a suitable unitary transformation composed of quantum gates. Finally, the output state of the quantum register is measured by which the classical readout is obtained.
For the QC C the notions of ''quantum input'' and ''quantum output'' have no genuine meaning if we restrict ourselves to the situation where the input state is known. As stated before, Shor's factoring algorithm ͓17͔ and Grover's search algorithm ͓18͔ are both examples of such a situation.
In these cases the final result of any computation -including quantum computations-is a classical number. In a QC C computation this number is extracted from the outcomes of all the one-qubit measurements. The entire computation amounts to just measurements of the cluster qubits in a certain order and basis.
We have divided the set C of cluster qubits into subsets I, M, and O to describe the QC C in terms of the network model. Such a terminology is not required for the QC C a priori. It is true that when a quantum logic network is realized on a cluster state there is a subset of cluster qubits that play the role of the output register. However, these qubits are not the final ones to be measured, but among the first ͑!͒. The measurement outcomes from all the cluster qubits contribute to the result of the computation. The qubits of OʚC simulate the output state of the quantum register and thus contribute obviously to the computational result. The cluster qubits in the set IʚC simulate the fiducial input state of the quantum register and their measurement contributes via the accumulated byproduct operator on O. Finally, the qubits in the section M ʚC of the cluster whose measurements simulate the quantum gates also contribute via the byproduct operator.
Naturally there arises the question whether there is any difference in the way how measurements of cluster qubits in I, O, or M contribute to the final result of the computation. As shown in Ref. ͓7͔, it turns out that there is none. This is why we can abandon the notions of quantum input, quantum output, and quantum register, altogether from the description of the QC C .
Furthermore, quantum gates are not constitutive elements of the QC C ; these are instead one-qubit measurements performed in a certain temporal order and in a spatial pattern of adaptive measurement bases. In fact, the most efficient temporal order of the measurements does not follow from the temporal order of the simulated gates in the network model.
The general view of a QC C computation is as follows. The cluster C is divided into disjoint subsets Q t ʚC with 0рt рt max , i.e., tϭ0 t max Q t ϭC and Q s പQ t ϭл for all sϭ " t. The cluster qubits within each set Q t can be measured simultaneously and the sets are measured one after another. The set Q 0 consists of all those qubits for which no measurement bases have to be adjusted, i.e., those of which the operator x , y , or z is measured. In the subsequent measurement rounds only operators of the form cos x Ϯsin y are measured where ͉͉Ͻ/2, 0. The measurement bases are adaptive in these rounds, i.e., they are adapted to measurement results obtained in previous rounds. The measurement outcomes from the qubits in Q 0 determine the measurement bases for the qubits in Q 1 , which are measured in the second round, those from Q 0 and Q 1 together determine the bases for the measurements of the qubits in Q 2 , which are measured in the third round, and so on. Finally, the result of the computation is calculated from the measurement outcomes obtained in all the measurement rounds ͑Fig. 8͒. Now there arises the question of how complex the required classical processing is. In principle, it could be that all the obtained measurement results had to be stored separately and the functions to compute the measurement bases were so complicated that one would gain no advantage over the classical algorithm for the considered problem. This is not at all the case. If the network algorithm runs on n qubits, then the classical data that the QC C has to keep track of is entirely contained in a 2n-component binary valued vector, which we have called the information flow vector I(t) ͓7͔. The update of I(t) is a classical computation that is needed to adapt the measurement bases of cluster qubits according to previous measurement outcomes. These updates and the final identification of the computational result from I(t max ) are all elementary.
Concerning the resources for the classical processing of the measurement outcomes in a QC C computation, we point out that this processing increases the total time of computation only marginally ͓7͔.
In summary, the formal description of the QC C is based on primitive quantities of which the most important ones are the sets Q t ʚC of cluster qubits, defining the temporal ordering of measurements on the cluster state and the binary-valued information flow vector I(t), which is the carrier of the algorithmic information. The reader who is interested in how this computational model arises and in its detailed description is referred to Ref. ͓7͔, or, for concepts and summary, to Ref. ͓8͔.

B. Quantum algorithms and graphs

In this section we relate QC C algorithms to graphs. We do this by considering non-universal graph states suited for the specific algorithm in question. For the QC C , the Clifford part of each algorithm can be removed. We show that a mathematical graph comprises all the information that needs to be kept of the Clifford part.
While the network formulation of a quantum algorithm is given as a sequence of quantum gates applied to a fiducial input state, the QC C version of a quantum algorithm is speci- FIG. 8. General scheme of the quantum computer via one-qubit measurements. The sets Q t of lattice qubits are measured one after the other. The results of earlier measurements determine the measurement bases of later ones. All classical information from the measurement results needed to steer the QC C is contained in the information flow vector I(t). After the last measurement round t max , I(t max ) contains the result of the computation. fied by a measurement pattern on the universal cluster state plus the structure ͓7͔ for the processing of the measurement outcomes.
To motivate the considerations of this section, note that the measurement pattern is, in the simplest case, just a copy of the network layout to the substrate cluster state, imprinted by the measurements. As such it contains information about the precise location of the gate simulations and about the way the ''wires'' connecting the gates are bent around. These are all details of the realization of an algorithm but do not belong to the description of the algorithm itself. Thus, the measurement pattern introduces a large amount of redundancy into the description of a QC C algorithm. This redundancy may be reduced to a large extent by allowing for nonuniversal, algorithm-specific quantum resources.
Clearly, at this point one has to specify how special the algorithm-specific resource is allowed to be. Obviously it would make no sense to take the quantum output of the entire network as the required quantum resource and to regard the subsequent readout measurements as the algorithm. Here, we allow for any graph state ͓9͔, Eq. ͑20͒ as the quantum resource. Graph states are easy to create, e.g., via unitary networks or from cluster states via measurements.
To allow for an algorithm-specific graph state as the quantum resource of a QC C computation reduces the redundancy of both the description and the realization of a quantum algorithm. This can easily be seen from the material presented in Sec. II C. All the cluster qubits qC\C N can be get rid of either by measuring them in the z eigenbasis or equivalently by not placing them initially into their positions at all. The remaining state on the subcluster C N is again a cluster state. Hence, it is also a graph state. It is less redundant and no longer universal.
But we can go further. Not only the qubits measured in the z eigenbasis may be removed from the cluster but instead all those qubits of which one of the Pauli operators x , y or z is measured, i.e., all the qubits which form the set Q 0 . The state of the unmeasured qubits that emerges after the measurement of the cluster qubits in Q 0 is again ͑local equivalent to͒ a graph state. This may be seen as follows. First note that the operators x (a) bV ( z (b) ) ⌫ ab , which appear in Eq. ͑20͒ form a stabilizer of the state ͉͕͖͘ G . The generator of the stabilizer contains ͉C͉ elements for a state of ͉C͉ qubits. After all the qubits qQ 0 have been measured, the resulting state ͉⌿͘ C\Q 0 of the ͉C\Q 0 ͉ unmeasured qubits is again described by a stabilizer of the form
with two ͉C\Q 0 ͉ϫ͉C\Q 0 ͉ matrices X and Z, for which X a,i ,Z a,i ͕0,1͖. The ͉C\Q 0 ͉ϫ2͉C\Q 0 ͉-compound matrix (X͉Z) ͓12͔ is called the generator matrix of the stabilizer for ͉⌿͘ C\Q 0 . The state ͉⌿͘ C\Q 0 is uniquely determined by the generator of its stabilizer.
The state ͉⌿͘ C\Q 0 can thus be regarded as a ͓͉C \ Q 0 ͉,0,d͔-stabilizer code, with the distance d not specified. This state fulfills the assumptions of Theorem 1 in Ref. ͓23͔. The cited theorem states that any stabilizer code over the alphabet AϭF p m is ͓local unitary͔ equivalent to a graph code.
We now specialize to the case of our interest, AϭF 2 2. It follows from the above-mentioned theorem that the state ͉⌿͘ C\Q 0 specified in Eq. ͑114͒ is local unitary equivalent to a graph state ͉͕͖͘ G(C\Q 0 ,E C\Q 0 ) Eq. ͑20͒. That is, the state ͉⌿͘ C\Q 0 obtained in a QC C computation after the first round of measurements may as well be obtained from a graph state ͉͕͖͘ G(C\Q 0 ,E C\Q 0 ) via local unitary transformations; and the subsequent measurements may be performed as usual. Alternatively, one may use the graph state ͉͕͖͘ G(C\ Q 0 ,E C\ Q 0 ) directly, only modifying the measurement bases instead of performing the local rotations prior to the measurements. Thus, in a QC C computation with a special graph state as the quantum resource and the first measurement round omitted, the way of processing the classical information is the same as in a QC C computation with a universal resource and the first measurement round performed.
The graphs associated with states ͑114͒ are, in general, not unique ͓23͔. A constructive way to obtain graphs on C\Q 0 from G(C,E C ) and the measurement bases of the qubits in Q 0 has been described in Ref. ͓24͔. Now note that the measurement of the qubits in Q 0 realize the Clifford part of a quantum circuit. The fact that we can reduce the quantum resource by these qubits means that we can remove from each quantum algorithm its Clifford part. This represents, in a way, an extension to the Knill-Gottesman theorem ͓22͔, stating that a quantum computation that consist only of quantum input state preparation in the computational basis, unitary gates in the Clifford group, measurement of observables in the Pauli group, and gates in the Clifford group conditioned on the outcomes of such measurements, may be simulated efficiently classically and thus requires no quantum resources at all.
With only a single non-Clifford operation in the circuit, such as a one-qubit rotation about most axes and angles, the efficient classical formalism on which the Gottesman-Knill theorem rests can no longer be applied. The QC C construction, on the other hand, is not affected by this. Each quantum network algorithm in question may be reduced by its Clifford part. Only the non-Clifford gates require quantum resources. The price is that the universal quantum resource, the cluster state, is changed into a nonuniversal, algorithm-specific resource-a graph state ͑20͒-on fewer qubits. The Clifford part of the network algorithm specifies the corresponding graph.
In conclusion, instead of describing a quantum algorithm as a network of gates applied to some fiducial input state, a quantum algorithm may ͑arguably more effectively͒ be characterized by a graph specifying the quantum resource and the structure ͓7͔ for the processing of the measurement outcomes.
the state ͉͘, into which the cluster qubits are projected after the second measurement round, obeys the eigenvalue equation
If we carry out this procedure for all equations in Eq. ͑118͒, we find that the state ͉͘ that emerges after the second measurement round obeys the eigenvalue equations
for iϭ1, . . . ,4 and with U 4 written in short for U 4 ͓Ϫ(Ϫ1) ͔.
With the set of Eqs. ͑124͒ assumptions ͑61͒ of Theorem 1 are fulfilled. With Theorem 1 it follows that the measurement pattern displayed in Fig. 9 realizes a unitary transformation
where the byproduct operator is given by
Finally, the order of the operators has to be exchanged. Note that U swap and U 4 commute. From Eq. ͑125͒ one finds
Thus, in order to realize U 4 ͓͔ with specified in Eq. ͑117͒ we must choose
That is, in the second measurement round we measure on the qubit (3,4) the operator given in Eq. ͑116͒, where
͕ x,i ͖, ͕ z,i ͖, and depend linearly on the measurement outcomes ͕s (i• j) ͖ obtained in the first measurement round.
The subcircuit we have described in this section simulates the unitary evolution according to a particular four-particle Hamiltonian in a two-step process of measurements. The time for which the simulated Hamiltonian acts is encoded in the basis of the measurement in the second round.
The generalization of the simulation of the four-particle Hamiltonian H 4 , shown in Fig. 9, to an arbitrary number n of qubits, i.e., the simulation of the Hamiltonian H n ϭ iϭ1 n z [i] , is straightforward. If the ''interaction time'' is set to zero, ϭ0, i.e., when the qubit (3,4) is measured in the x eigenbasis as well, then one obtains a multiqubit SWAP gate, which reverses the order of the logical qubits, In this case, only a single measurement round is required. The multiqubit SWAP gate is displayed in Fig. 10.

B. CNOT between non-neighboring qubits

The CNOT gate described in Sec. II G 7 operates on two logical qubits whose input qubits are adjacent to each other on the cluster. However, for universal quantum computation, one must be able to realize a CNOT gate between any two logical qubits. While this could be achieved using a combination of the CNOT gate, introduced above, and the SWAP gate, the width of the measurement pattern needed to realize this would grow linearly with the separation of the two logical qubits. There is, however, an alternative measurement pattern, which, at the cost of doubling the spacing between the input qubits on the cluster, has a fixed width.
The measurement pattern is illustrated in Fig. 11 for qubits separated by an odd and even number of logical qubits, respectively.
This layout can be understood within the quantum logic network model. The ''wires'' for the logical qubits in between the target and the control qubits are crossed, using the measurement subpattern, illustrated in Fig. 12͑a͒. However, as well as swapping the qubits, this pattern also realizes a controlled -phase gate, also known as a controlled z gate, illustrated in Fig. 12͑b͒.
The quantum logic circuit realized by the whole measurement pattern, illustrated on the left-hand side of Fig. 13 uses these subpatterns to swap the positions of adjacent qubits. This brings non-neighboring qubits together so that a CNOT operation may be performed on them. The networks on the left and on the right of Fig. 13 act identically, and thus the measurement pattern displayed in Fig. 11 realizes a distant CNOT gate.

C. Controlled phase gate

Here, we give an example of another two-qubit gate, which can be realized without decomposing it into CNOTs and rotations, the controlled phase gate U CPG (). This gate realizes the unitary operation
applied to the two qubits a and b.
We can write this in terms of the following one-and twoqubit rotations:
where the two-qubit rotation is
This representation is particularly convenient for finding the measurement pattern that realizes the gate, since rotations U z ͓/2͔ and U zz ͓Ϫ/2͔ are realized on the QC C in a simple natural way. The measurement pattern is illustrated in Fig. 14, in which the labelling of the qubits is also defined.
We follow the same method as above, beginning with the eigenvalue equations of the cluster state ͉͘ C on the qubits shown. The x measurements can be considered first, using the methods already illustrated in this paper. The resultant state of the remaining qubits, ͉Ј͘, after this subset of the measurements has been carried out, is defined by the following set of eigenvalue equations:
FIG. 11. Measurement pattern for a CNOT gate between two logical qubits whose input and output qubits are not neighbors. Squares in light gray denote cluster qubits measured in the eigenbasis of x , in dark gray of y . Pattern ͑a͒ is for the case where the two qubits are separated by an odd number of logical qubits. Pattern ͑b͒ is for an even-numbered separation. The patterns can be adapted to any separation by repeating the section enclosed by the dashed line. The width of the pattern remains the same for all separations.
FIG. 12. This measurement pattern is one of the key components of the measurement pattern in Fig. 11. It performs a conditional -phase gate and a SWAP gate.
FIG. 13. The measurement pattern in Fig. 11 realizes the quantum logic circuit on the left-hand side of this figure. This network is equivalent to that on the right-hand side, where the only gate realized is the CNOT between the two desired nonadjacent qubits.
FIG. 14. Controlled phase gate with additional swap.
MEASUREMENT-BASED QUANTUM COMPUTATION ON . . . PHYSICAL REVIEW A 68, 022312 ͑2003͒ extension of the method described in Sec. II G 2. Finally, one obtains the QC C circuit displayed in Fig. 16.
In this circuit, as in all the others, the adaptive measurements are of observables
with ϭ/4 for cluster qubits marked with ''2'' in Fig. 16, ϭ/8 for qubits marked with ''3,'' and ϭ/16 for the qubits marked with ''4.'' The sign factors of the angles in Eq. ͑140͒ depend on the results of previous measurements. The QC C circuit, shown in Fig. 16 for the case of four qubits, is straightforwardly generalized to an arbitrary number n of logical qubits. The temporal spatial and operational resources T, S, and O are, to leading order Tϭn, S,Oϭ2n 2 . ͑141͒
The corresponding network resources are T qln ϭ2n, S qln ϭn, and O qln ϭn 2 /2. Thus, the scaling of the QC C spatial resources is worse than in the network model, but the temporal and operational resources scale in the same way as the corresponding resources for the network. The QC C simulation of the network displayed in Fig. 15 requires half as many time steps and four times as many operations, albeit only one-qubit operations.

E. Multiqubit controlled gates

In this section we describe the realization of the Toffoli phase gate and the three-qubit controlled gate CARRY, which we will both need for the construction of the QC C -adder circuit described in Sec. IV F.
The Toffoli phase gate is a three-qubit generalization of the two-qubit controlled phase gate. If all three qubits are in the state ͉1͘, the state gains a phase of exp(i), while all other logical basis states remain unchanged by the gate:
Like the controlled phase gate it can be represented as a product of multiqubit rotations,
where we have dropped the global phase, and U zzz (c 1 ,c 2 ,t) ͓␣͔ ϭexp(Ϫi␣/2 z (c 1 ) z (c 2 ) z (t) ) is a three-qubit generalized rotation. The two-qubit rotations U zz are as defined in Eq. ͑133͒. The way to convert sequence ͑143͒ of generalized rotations into a measurement pattern is as in the examples be- FIG. 17. A measurement layout to realize a Toffoli phase gate with phase . The qubits marked by black boxes are simultaneously measured in adapted bases, depending on previous measurement outcomes. fore. The measurement layout for the Toffoli phase gate is illustrated in Fig. 17. Each of the generalized rotations that make up the gate is directly associated with one of the measurements made in the eigenbasis of U z ͓Ϯ/4͔ x U z ͓Ϯ/4͔ † . An initial cluster-state correlation, which is used for the realization of a generalized rotation, is shown in Fig. 18; the rotation U zz (c 1 ,c 2 ) ͓/4͔ is realized via the measurement of the cluster qubit at the lattice site (3,1) in the appropriate basis. The sign factors of the angles that specify the measurement bases depend on the outcome of x measurements only. Thus, after all x measurements have been performed, the measurement bases for the remaining qubits can be deduced and the Toffoli phase gate is realized in a single further time step. The measurement pattern realizes the generalized rota-tions directly and is not derived from a quantum logic network. Now we describe the realization of a four-qubit gate CARRY, which has one target and three control qubits. It performs a phase-flip z on the target if at least two of the control qubits are in state ͉1͘ and otherwise does nothing, i.e.,

͑144͒

Expanding the projectors on the control qubits into products of the Pauli operators one obtains

͑145͒

The global phase is henceforth discarded.
The unitary transformation is now subdivided into two parts:
with U aϪg ϭU g U f U e U d U c U b U a and U h,i ϭU i U h . Correspondingly, the cluster on which U CARRY is realized is divided into two subclusters. On the first subcluster the transformations U a to U g are realized, on the second subcluster U h,i . The measurement pattern to realize U CARRY is displayed in Fig. 19. The first subcluster stretches from xϭ0 to xϭ8, with the input at xϭ0 and the intermediate output at xϭ8. The qubits with 8рxр16 belong to the second subcluster.
Let us now explain the subgate U aϪg . The conversion of sequence ͑145͒ of generalized rotations is as in the previous examples. For each generalized rotation there is one cluster qubit in C M (U aϪg ) whose measurement basis specifies the respective rotation angle. Specifically, the measurement of the cluster qubit (3,4) sets the rotation angle of U a , the measurement of qubit (4,3) sets the angle for U b , (5,6) sets U c , (6,7) sets U d , (6,5) sets U e , (6,3) sets U f , and qubit (6,1) sets U g . The quantum correlations of the initial cluster state, which induce via the measurements of the cluster qubits in C M (U aϪg ) the quantum correlations associated with the generalized rotations are displayed in Fig. 20.
The realization of the gate requires two measurement rounds. In the first round the standard measurements of x and y are performed. Note that the rotation angle of U d is twice as big as for the other rotations. To realize U d of the cluster qubit (6,7) the observable
is measured. Thus, the realization of U d belongs to the first round of measurements. Strictly speaking, this measurement round does not belong to the gate but to the circuit as a whole since all standard measurements are performed simultaneously.
In the second measurement round, of the remaining qubits in C M (U aϪg ) one measures the observables

͑148͒

The procedure to infer the sign factors in Eqs. ͑148͒ and ͑147͒ is explained in Sec. II F. The reason why the measurements in the tilted bases may all be performed simultaneously in the second round can be seen as follows. Let Q be the set of qubits measured in tilted bases. The contribution U ⌺,Q of the cluster qubits measured in tilted bases to the byproduct operator U ⌺ in Eq. ͑63͒ contains only a z part but no x part. That is, it has the form
In Eq. ͑62͒ the byproduct operator appears ''on the wrong side'' of U aϪg as does the contribution U ⌺,Q . When the order of the gate and the byproduct operator is exchanged, the byproduct operator may modify the gate. While this is, not surprisingly, indeed the case for the whole U ⌺ , it is not so for the contribution U ⌺,Q coming from the measurements in the tilted bases. Because U ⌺,Q has only a z part, it commutes with U aϪg . Therefore, the results of measurements in a tilted basis do not mutually affect the choice of their measurement bases. FIG. 21. Quantum correlations of the initial cluster states on C(U h ) and C(U i ). These correlations induce, via the x measurements, the quantum correlations for the states ͉Ј͘ C(U h ) and ͉Ј͘ C(U i ) that involve only the respective output qubits and one qubit in the gate body. The pattern of correlation centers in ͑a͒ displays the correlation required to realize U h and ͑b͒ the correlation for U i .
FIG. 20. Quantum correlations of the initial cluster state ͉͘ C(U aϪg ) on the cluster C(U aϪg ). These correlations induce, via the x measurements, the quantum correlations for the state ͉Ј͘, which act only on the output qubits and one cluster qubit in C M (U aϪg ). The pattern of correlation centers in ͑a͒ displays the correlation required to realize U a ; ͑b͒, ͑c͒, and ͑d͒ display the correlations for U b , U c , and U e , respectively. The correlations used for the realization of U d , U f , and U g are not shown. They are analogous to that in ͑d͒ used for the realization of U e .
The fact that the byproduct operator U ⌺,Q is indeed of form ͑149͒, we do not show here explicitly. For the byproduct operator created in the measurement of qubit (3,4), realizing the transformation U a it may be verified from Eq. ͑126͒ in Sec. IV A.
The explanation of the second subgate U h,i is analogous. Figure 21 displays the quantum correlations of the initial cluster state, which, via the measurements in C M (U h,i ), induce the required quantum correlations associated with U h and U i .
Two further points we would like to address in this section. The first is to note that the whole gate U CARRY can be performed on the QC C in two measurement rounds. The first measurement round is that of the x , y , and z measurements, which, strictly speaking, does not belong to the gate but to the circuit as a whole. The second measurement round is that of the simultaneous measurements in tilted measurement bases.
We have already seen that the measurements that realize the unitary transformations U a , . . . ,U g may be realized simultaneously, and this argument may be extended to the entire gate U CARRY . All the byproduct operators created with the measurements in tilted bases have only a z but no x part. Therefore, they all commute with U CARRY . Thus, to choose the right measurement bases neither of the measurements in a tilted basis that realizes one of the rotations U a , . . . ,U i needs to wait for another measurement in a tilted basis.
Second, note that for U CARRY the target input and the target output can be interchanged, see Fig. 22. This holds because the ͑conditional͒ phase flip on the target qubit is its own inverse. Thus, the target qubit may travel through the gate backwards. This property also holds for the Toffoli phase gate. We will make use of it in the construction of the quantum adder in the following section.

F. Circuit for addition

The QC C version of the quantum adder corresponds to the quantum logic network as given in Ref. ͓26͔,see Fig. 23. In this paper we use the three-qubit controlled phase gate CARRY together with a prior and subsequent Hadamard gate on the target qubit while in Ref. ͓26͔ the equivalent threequbit controlled spin-flip gate is used directly.
At first sight it appears as if the horizontal dimension of the cluster to realize the adder circuit would grow linearly with the number of logical qubits n. This is, however, not the case. The QC C circuit may be formed in such a way that the horizontal size of the required cluster is constant such that the cluster size increases only linearly with the number n of logical qubits. To see what the QC C realization of the quantum adder will look like, the network displayed in Fig. 23 may be bent in a way displayed in Fig. 24.
To ''bend a network'' is a rather informal notion. We therefore now specify what we mean by this. If a quantum circuit is displayed as a quantum logic network, the vertical axis usually denotes some spatial dimension, i.e., the location of the qubit carriers, and the horizontal axis corresponds to the sequence of steps of a quantum computation, i.e., a logical time. As the basic blocks of quantum computation in the network model, the universal gates, are unitary transformations generated by suitably chosen Hamiltonians, the logical time becomes associated with physical time. This is, however, a peculiarity of the network model. If on the QC C a quantum logic network is simulated, the temporal axis is converted into an additional spatial axis. The temporal axis in a QC C computation emerges anew. It has no counterpart in the network model. If we modify a quantum logic network in such a way that qubits travel from right to left, as done in Fig. 24, it does not mean that we propose to use particles that FIG. 22. In the three-qubit controlled gate CARRY, the target qubit may travel either back or forth.
FIG. 23. Quantum logic network for four-qubit adder, cϭaϩb mod 2 4 . The adder network is taken from Ref. ͓26͔. The two-qubit controlled gate in this network is the Tofolli phase gate, as discussed in Sec. IV E. A straightforward simulation of this network on the QC C would result in a quadratic scaling of spatial resources. However, the more compact realization discussed below requires only a linear overhead. travel backwards in time because we do not need to respect the temporal axis implied by the network model. If one wants a seminetwork picture that accounts for this, one may imagine the logical qubits as traveling through pipes on a two-dimensional surface.
The reason why we may let the auxiliary qubits travel ''backwards'' is the identity displayed in Fig. 22. This arrangement of gates makes the circuit more compact. To complete the description of components from which the QC C version of the quantum adder is built, a compact measurement pattern for the two combined CNOT gates is displayed in Fig. 25.
The realization of the quantum adder in the network layout of Fig. 24 directly leads to the QC C circuit for the quantum adder displayed in Fig. 26. Note that the displayed QC C adder is for eight qubits, while the networks in Figs. 23 and 24 are only for four qubits.
For the quantum adder circuit in Fig. 26 we have made two further minor simplifications. The first concerns the ancilla preparation. To prepare an ancilla qubit on the cluster in the state ͉ϩ͘ means to measure the respective cluster qubit in the x eigenbasis ͑the randomness of the measurement outcome does not jeopardize the deterministic character of the circuit͒. As can be seen from the Toffoli gate and the three-qubit controlled gate, displayed in Figs. 17 and 19, the ancilla qubits are located on cluster qubits that have only one next neighbor. As can be verified from eigenvalue equations ͑1͒, to measure a qubit of a cluster state that only has one next neighbor in the eigenbasis of x also has the effect of projecting this neighboring cluster qubit into an eigenstate of z . Such cluster qubits may be removed from the cluster as explained in Sec. II C. With these neighboring qubits removed, the cluster qubits on which the initial ancilla qubits were located become disconnected from the remaining cluster and may thus be removed as well. With the same argument, the cluster qubits carrying the ancillas in their output state, and their next neighbors may also be removed.
Second, between the QC C realization of the CARRY gates on the left and the subsequent blocks of CNOT gates we have FIG. 26. Quantum adding circuit for two eight-qubit states. As in all figures displaying QC C circuits, squares in light and dark gray represent cluster qubits measured in the x and y eigenbasis, respectively. The measurement bases of qubits displayed as framed squares are adaptive. removed pairs of adjacent cluster qubits that would be measured in the eigenbasis of x . Why this can be done has been explained for adjacent qubits in wires in Sec. II G 2. Here the situation is little more involved since, like in the case of the circuit for the Fourier transformation displayed in Sec. IV D, one of the removed qubits in each pair has more than two neighbors. But the method still works as can be easily verified.
Let us now briefly discuss the resources required for the QC C realization of an n-qubit adder. As can be seen directly from the circuit displayed in Fig. 26 and the underlying network shown in Fig. 24 with its repeating sub-structure, the adder requires a cluster of height 8nϪ5 and of constant width 38. Thus, the spatial and operational resources are, to leading order,

SϭOϭ304n. ͑150͒

Concerning the temporal resources note that each pair of three-qubit controlled phase gates using the same control qubits and the pair of the Toffoli phase gates may be completed at one time instant but that one pair of gates is completed after another. The reason why the measurements in the tilted bases that complete each pair of gates may be performed simultaneously is the same as that given previously for the measurements in tilted bases of a single three-qubit controlled gate. The propagation of byproduct operators is most easily followed in the network of Fig. 23. The temporal complexity T of an n-qubit QC C adder is

Tϭn, ͑151͒

plus one step of x , y , and z measurements for the entire circuit.
The corresponding network resources are, to leading order, S qln ϭ3n and O qln ϭT qln ϭ8n. For the counting of the operational and temporal network resources, we have assumed that the three-qubit controlled spin-flip gate used in the addition circuit is composed of two Toffoli gates and one CNOT gate, as described in Ref. ͓26͔, and that the CNOT and the Toffoli gates are regarded as elementary.
Thus, we find for both the network and the QC C realization of the quantum adder that the spatial, temporal, and operational resources scale linearly with n. Therefore, the resource overheads in one realization as compared to the other one are only constants. For the QC C this is much better than what is indicated by bounds ͑111͒-͑113͒, in particular, for the spatial and operational resources. Equation ͑112͒ yields an upper bound on S, which is ϳn 3 , and Eq. ͑113͒ gives bounds on O and S, which are ϳn 2 . Thus, the quantum adder is an example for which these bounds are very loose. In general, they should not be mistaken as estimates.
If the prefactors are compared, one finds that for the realization of a quantum adder the QC C requires about 100 times more spatial and 38 times more operational resources, while it is eight times faster. However, since we compare different objects, these ratios do not mean much apart from the fact that they are constants. It may be argued that in the case of the QC C spatial resources are not as precious as they usually are, to create cluster states one needs a system with nonse-lective uniform interaction only while for quantum logic networks one generally requires a system with selective interactions among the qubits. Concerning the operational and temporal resources, the QC C only uses one-qubit measurements, while the corresponding network uses two-and threequbit gates as elementary operations.

G. Remarks

We would like to add two remarks, one with regard to the elementary constituents of the QC C and the other with regard to their composition principle.
For the particular set of gate simulations used in the QC C universality proof in Sec. II, the CNOT gate and arbitrary one-qubit rotations, there is only a single instance where one of these gates has been used as part of a more complicated gate in all examples of this section. Namely, the nextneighbor CNOT gate has been used as part of the longdistance CNOT, described in Sec. IV B. Of universal gate simulations one might expect that any circuit is composed of them rather that they occur almost not at all. One could say, though, that the used set of gates is not a good choice for the universal set. In fact, in realizations of network quantum computers it is often the physics of the specific implementation that determines which gates are elementary. For the QC C this is not so. The QC C may simulate, for example, general one-qubit rotations and the Toffoli gates alike. Any gate simulation may be called ''elementary'' with the same right as any other, but they cannot be all elementary. The elementary constituents of the QC C are not gate simulations.
As a consequence, the composition principle for these elements will be different from gate composition. At first sight, if we go through the examples of this section, we find that this is not yet reflected in the larger and more complicated constructions. For the quantum Fourier transform and the addition circuit we have, though playing with some tricks, ultimately imitated network composition.
However, in the smaller gates and subcircuits, such as the controlled phase gate, the Toffoli phase gate and the gate CARRY we find something that might give rise to a more appropriate composition principle. First, for the QC C it is not the one-qubit and two-qubit operations that are particularly simple. In the Hamiltonian simulation circuit of Sec. IV A we found that it is easy to realize generalized rotations exp(i (J) ) where (J) is a composite Pauli operator, (J) ϭ aJ k a (a) , k a ϭx,y,z. Furthermore, in the subsequent examples of the multiqubit gates in Secs. IV C and IV E we have decomposed the gates into such generalized rotations rather than into known standard gates on fewer qubits. Any unitary transformation may be decomposed into a unitary transformation in the Clifford group followed by generalized rotations. So, is this a new composition principle? With our present state of knowledge, the answer must be ''Not yet.'' First, though any transformation may be rewritten in this form, it is presently not clear how to design quantum algorithms with these elements directly. Second, the construction uses the very concept of applying unitary transformations to the state of a quantum register. However, as we have explained in Ref. ͓7͔ and also briefly sketched in Sec. III A, the QC C has no quantum register. So, the generalized rotations and their concatenation at least have to be reformulated to fit the description of the QC C . In particular, they have to be made compatible with the graph states identified in Sec. III B as characteristic quantum resource to represent algorithms. Nevertheless, it appears that the generalized rotations should be reflected in what may emerge as elementary constituents and composition principle for the QC C .

V. COMPUTATION WITH LIMITED SPATIAL RESOURCES AND IN THE PRESENCE OF DECOHERENCE

In this section we describe how to perform QC C computation on finite and possibly small clusters. If the cluster that may be provided by a specific device is too small for a certain measurement pattern, it does not mean that the respective QC C algorithm cannot be run on this device. Instead, the QC C computation may be split into several parts such that each of those parts fits on the cluster.
To see this, consider Scheme 1 for the realization of gates. Scheme 1 is applicable to any gate or subcircuit. It is thus possible to divide the circuit into subcircuits, each of which fits onto the cluster. The adapted scheme is a process of repetitive reentangling steps alternating with rounds of measurements.
Specifically, one starts with the realization of the first subcircuit acting on the fiducial input state located at I 1 ʚC. The fiducial input is, while being processed, teleported to some subset O 1 of the cluster C. The set O 1 of qubits forms the intermediate output of the first subcircuit. These qubits remain unmeasured, while all the other qubits are measured to realize the first subcircuit. Now the realization of the second subcircuit begins. Its input state has already been prepared, I 2 ϭO 1 . The cluster qubits aC\O 1 , which have been measured in the realization of the first subcircuit, are now prepared individually in the state ͉ϩ͘ a . This completes Step 1 of Scheme 1 to realize the second subcircuit.
Step 2 is to entangle the whole cluster via the Ising interaction. In the third step all cluster qubits except those of the intermediate output O 2 are measured whereby the realization of the second subcircuit is completed. The intermediate output is now located at O 2 . For the realization of the subsequent subcircuits one proceeds accordingly.
An advantage of this modified procedure is that one gets with smaller clusters. A disadvantage is that the Clifford part of the circuit may no longer be performed in a single time step.
Perhaps the most important advantage of the above con-struction is that in this way a basic requirement to make the QC C fault tolerant can be fulfilled. Namely, decoherence can be controlled. If a single large cluster is used, the computation might reach certain cluster qubits only after a long time such that the cluster would have already decohered significantly and it is not clear how error correction could help in such a situation. This might, for any error rate, limit the duration of a computation. On the contrary, if the computation is split then the size of the subcircuits may be adjusted such that each of them can be performed within a fixed time T and in this way, each cluster qubit is, before being measured, exposed to a bounded amount of decoherence specified by T. Thus, ''fresh'' qubits for computation are always provided.

VI. CONCLUSION

In this paper we have given a detailed account of the one-way quantum computer. We have shown that the QC C can be regarded as a simulator of quantum logic networks. This way, we clarified the relation of the QC C to the network model of quantum computation and gave the universality proof.
We have based our description on the correlations exhibited by cluster states and states that can be created from them under one-qubit measurements. For this purpose, Theorem 1 of Sec. II F is an important tool. It relates unitary transformations to quantum correlations exhibited by certain pure states.
In Sec. IV we have presented a number of example circuits such as the circuit for quantum Fourier transformation and for addition. In this way, hopefully, we also have acquainted the reader with a number of construction principles for QC C circuits. Note that the simulations of the universal gates required in the universality proof are hardly used. Instead, more compact measurement patterns have been found.
The main purpose of this paper is to provide a comprehensive description of the QC C from the network perspective. Beyond that, we have pointed out the non-network aspects of the QC C , such as the different nature of information processing ͓7,8͔, and the connection to mathematical graphs.

FIG. 7 .

7Pattern of correlation centers representing eigenvalue equation ͑107a͒.

FIG. 10 .

10Measurement pattern that realizes the multiqubit SWAP gate.

FIG. 18 .

18Cluster state quantum correlations for the realization of U zz (c 1 ,c 2 ) ͓/4͔, used in the Toffoli phase gate.FIG. 19. The three-qubit controlled gate. Qubits displayed as squares in light gray are measured in the x eigenbasis, the qubit displayed in dark gray is measured in the y eigenbasis, and the measurement bases of the qubits displayed as framed squares are adaptive.FIG. 16. QC C realization of a quantum Fourier transformation on four qubits. The cluster qubits displayed as framed squares are measured in adapted bases. For the labels see text.

FIG. 24 .

24Quantum logic network for four-qubit adder, bent.FIG. 25. Combination of two CNOT gates ͑a͒ and its QC C realization ͑b͒.
ACKNOWLEDGMENTSThis work was supported by the Deutsche Forschungsgemeinschaft ͑DFG͒ and in part by IST-1999-13021. We would like to thank D. Schlingemann, M. Grassl, M. Hein, H. Aschauer, B. Neuburger, and H. Wagner for valuable discussions.IV. EXAMPLES OF PRACTICAL INTERESTA. Simulating multiqubit HamiltoniansHere we display a gate that simulates the unitary evolution with Uϭexp(ϪiH 4 t) of the quantum input for the multiparticle Hamiltonian͑115͒and arbitrary times t. In addition, the gate performs a SWAPgate, i.e., the order if the logical qubits is reversed. The procedure to realize the measurement pattern M for Hamiltonian simulation, as shown inFig. 9, requires two rounds of measurements. In the first round all the x measurements are performed. In the second measurement round, of the qubit (3,4) the operatoris measured, where U z ͓␣͔ϭexp(Ϫi␣ z /2). Therein, the angle is given byϭgt, ͑117͒and M ͕0,1͖, which depends linearly on outcomes of measurements in the first round, will be specified below.To understand the functioning of the Hamiltonian simulator, let us first discuss the state ͉Ј͘ on the cluster C(sim) after the first round of measurements. By the techniques for stabilizer manipulation described in Ref.͓10͔, the state ͉Ј͘ obeys the following eigenvalue equations:Further, the state ͉Ј͘ obeys the eigenvalue equationwith ͕0,1͖ linear in the measurement outcomes of the first round. Equation ͑119͒ can be easily verified with the pattern of correlation centers displayed inFig. 9͑b͒. From ͑119͒ it follows thatfor arbitrary angles , withEquation͑120͒is now inserted in both the lhs and the rhs of Eqs. ͑118͒. For example, with the first equation from Eq. ͑118͒, one obtainsIn the second measurement round the qubit (3,4) is the only one left to be measured. As can be seen from Eq. ͑122͒, if the operator U z ͓2͔ x U z † ͓2͔ of qubit ͑3,4͒ is measured, thenFIG. 9. Simulation of the Hamiltonian H 4 as specified in Eq. ͑115͒. ͑a͒ Measurement pattern. ͑b͒ Correlation centers for additional correlation. Shaded squares ͓in ͑b͔͒ represent cluster qubits measured in adaptive bases.As in Sec. II G 3, eigenvalue equations are now generated, which commute with the remaining measurements in M, namely the measurements of xy (i) (␣ i ) on qubits i ͕(2,1),(1,2),(2,3)͖. First, we manipulate Eqs. ͑135͒ such that, for example, eigenvalue equation ͑135c͒ attains the formSimilar equations containing one-qubit rotations on qubits (2,1) and (O,a), and (2,3) and (O,b) are derived from the other equations of Eqs. ͑135͒ in the same way. These equations are inserted into both sides of eigenvalue equations ͑134͒ so that, using the method introduced above, we obtain a set of four eigenvalue equations for ͉Ј͘, which induce a set of four eigenvalue equations for the state ͉͘ that one obtains after the remaining measurements have been carried out. Specifically, in the second measurement round the qubits (1,2), (2,1), and (2,3) are measured. Of these qubits one measures the observablesfor a͕(1,2),(2,1),(2,3)͖ and ͕␣ a ͖ specified below.The induced eigenvalue equations for the state ͉͘ are of the form of Eq. ͑61͒, and the unitary operation realized by the gate can be read off from them, using Theorem 1. The full unitary operation realized by the measurement pattern issuch that after the order of the gate and the byproduct operator is reversed, UЈU ⌺ Ј ϭU ⌺ U, one obtainsUsing Eq. ͑139͒ one finds the following result: To realize the controlled phase gate ͑131͒ together with a SWAP gate, observables ͑137͒ measured in the second round have to be chosen with the angles ␣ (2,1) ϭ(Ϫ1) 1ϩs (2,2) ϩs (1,3) /2, ␣ (1,2) ϭ(Ϫ1) s (1,1) ϩs (2,2) ϩs (1,3) /2 and ␣ (2,3) ϭ(Ϫ1) s (1,1) ϩs (2,2) ϩ1 /2. This realizes the gate U ⌺ U CPG ͓͔, where the byproduct operator U ⌺ generated by the measurements may be read off from Eq. ͑139͒.D. Quantum Fourier transformationTo realize the quantum Fourier transform we simulate the quantum logic network given inFig. 15͑a͒. The arrangement of the gates in this network is taken from Ref. ͓25͔. Note that in Ref.͓25͔it was demonstrated that the setup to perform a quantum Fourier transformation simplifies considerably in a situation where the output state is measured right after the transformation. Here, however, the quantum Fourier transformation may constitute part of a larger quantum circuit and we do not measure its output state.As can be seen fromFig. 15, the quantum Fourier transform consists of the Hadamard gates and combined gates that perform a conditional phase shift and a swap. These gates have been discussed in Secs. II B and IV C. All that remains to do is to put the measurement patterns simulating these gates together, using the networklike composition principle described in Sec. II D.In this way we obtain a measurement pattern in which there are adjacent cluster qubits in ''wires'' that are measured in the x eigenbasis. As described in Sec. II G 2, such pairs of cluster qubits may be removed from the measurement pattern. Note that by removing adjacent pairs of x -measured cluster qubits, we have moved the y measurements of the Hadamard transformations ''into'' the subsequent conditional phase gates, i.e., we removed a cluster qubit that was not from a wire. It can be easily verified that this is an allowedFIG. 15. Quantum Fourier transformation. ͑a͒ Network for quantum Fourier transformation on four qubits, taken from Ref.͓25͔. ͑b͒ Component of the network shown in ͑a͒, which performs a conditional phase and a SWAP gate. Specifically, the gate shown is U CPG ͓2/2 m ͔, i.e., U m ϭ͉0͗͘0͉ϩe i2/2 m ͉1͗͘1͉.
. R Raussendorf, H J Briegel, Phys. Rev. Lett. 862001R. Raussendorf and H.J. Briegel, Phys. Rev. Lett. 86, 5188 ͑2001͒.
. H J Briegel, R Raussendorf, Phys. Rev. Lett. 862001H.J. Briegel and R. Raussendorf, Phys. Rev. Lett. 86, 910 ͑2001͒.
. M A Nielsen, I L Chuang, Phys. Rev. Lett. 791997M.A. Nielsen and I.L. Chuang, Phys. Rev. Lett. 79, 321 ͑1997͒.
. I L ͓4͔ D. Gottesman, Chuang, Nature ͑London͒. 4021999͓4͔ D. Gottesman and I.L. Chuang, Nature ͑London͒ 402, 390 ͑1999͒.
. E Knill, R Laflamme, G J Milburn, Nature ͑London͒. 4092001E. Knill, R. Laflamme, and G.J. Milburn, Nature ͑London͒ 409, 46 ͑2001͒.
. M A Nielsen, quant-ph/0108020M.A. Nielsen, e-print quant-ph/0108020;
. D W Leung, quant-ph/0111122D.W. Leung, e-print quant-ph/0111122.
. H J ͓7͔ R. Raussendorf, Briegel, Quantum Inf. Comput. 62002͓7͔ R. Raussendorf and H.J. Briegel, Quantum Inf. Comput. 6, 443 ͑2002͒.
. R Raussendorf, H J Briegel, quant-ph/0207183R. Raussendorf and H.J. Briegel, e-print quant-ph/0207183.
. D Schlingemann, R F Werner, Phys. Rev. A. 65D. Schlingemann and R.F. Werner, Phys. Rev. A 65, 012308 ͑2001͒.
. D Gottesman, quant-ph/9705052D. Gottesman, e-print quant-ph/9705052.
. D Gottesman, Phys. Rev. A. 571998D. Gottesman, Phys. Rev. A 57, 127 ͑1998͒.
. A R Calderbank, E M Rains, P W Shor, N J A Sloane, Phys. Rev. Lett. 781997A.R. Calderbank, E.M. Rains, P.W. Shor, and N.J.A. Sloane, Phys. Rev. Lett. 78, 405 ͑1997͒.
M A Nielsen, I L Chuang, Quantum Computation and Quantum Information ͑Cambridge University Press. CambridgeM.A. Nielsen and I.L. Chuang, Quantum Computation and Quantum Information ͑Cambridge University Press, Cam- bridge, 2000͒.
. D Jaksch, cond-mat/0210564Phys. Rev. Lett. 82D. Jaksch et al., Phys. Rev. Lett. 82, 1975 ͑1999͒. ͓15͔ L.-M. Duan, E. Demler, and M.D. Lukin, e-print cond-mat/0210564.
͓16͔ R, Diestel, Graphentheorie ͑Springer-Verlag. Heidelberg͓16͔ R. Diestel, Graphentheorie ͑Springer-Verlag, Heidelberg, 2000͒.
. P W Shor, SIAM J. Sci. Statist. Comput. 26P.W. Shor, SIAM J. Sci. Statist. Comput. 26, 1484 ͑1997͒.
. L K Grover, Phys. Rev. Lett. 791997L.K. Grover, Phys. Rev. Lett. 79, 325 ͑1997͒.
. E Knill, R Laflamme, W H Zurek, quant-ph/9702058E. Knill, R. Laflamme, and W.H. Zurek, e-print quant-ph/9702058.
. S Perdrix, S. Perdrix ͑unpublished͒.
C Moore, M Nilsson, e-print quant-ph/9808027. ͓22͔ Theorem 10.7 in Quantum Computation and Quantum Information ͑Ref. ͓13͔͒. C. Moore and M. Nilsson, e-print quant-ph/9808027. ͓22͔ Theorem 10.7 in Quantum Computation and Quantum Infor- mation ͑Ref. ͓13͔͒.
M Grassl, A Klappenecker, M Rötteler, IEEE International Symposium on Information Theory. Lausanne45M. Grassl, A. Klappenecker, and M. Rötteler, in IEEE Interna- tional Symposium on Information Theory, Lausanne, 2002 ͑unpublished͒, p. 45.
. D Schlingemann ͑private Communication͒, D. Schlingemann ͑private communication͒.
. R B Griffiths, C.-S Niu, Phys. Rev. Lett. 761996R.B. Griffiths and C.-S. Niu, Phys. Rev. Lett. 76, 3228 ͑1996͒.
. V Vedral, A Barenco, A Ekert, quant-ph/9511018V. Vedral, A. Barenco, and A. Ekert, e-print quant-ph/9511018.


8839192:A fault-tolerant one-way quantum computer


Introduction

A quantum computer as a physical device has to cope with imperfections of its hardware.Fortunately, it turns out that arbitrary large quantum computations can be performed with arbitrary accuracy, provided the error level of the elementary components of the quantum computer is below a certain threshold.This is the content of the threshold theorem for quantum computation [1,2,3,4].The threshold theorem also provides lower bounds to the error threshold which are in the range between 10 −10 and 10 −4 , depending on the error model.It thus appears that there is a gap between the required and the currently available accuracy of quantum operations, and it invites narrowing from both the experimental and the theoretical side.In this context, significant progress has been made in [5] where a threshold estimate in the percent range has been demonstrated.For experimentally viable quantum computation there is a further desideratum besides a high error threshold.With the exception of certain schemes for topological quantum computation [6,7,8], the price for fault-tolerance is an overhead in quantum resources.This overhead should be moderate.
Here we describe a fault-tolerant version of the one-way quantum computer (QC C ).The QC C is a scheme for universal quantum computation by one-qubit measurements on cluster states [9].Cluster states [10] consist of qubits arranged on a two-or three-dimensional lattice and may be created by a nearest-neighbor Ising interaction.Thus, for the QC C , only nearest-neighboring qubits need interact and furthermore, only once at the beginning of the computation.For this scenario in three dimensions we present methods of error correction and a threshold value.
The existence of an error threshold for the QC C has previously been established [11,12,13] and threshold estimates have been obtained [12,13], by mapping to the circuit model.Here we take a different path.We make use of topological error correction capabilities that the cluster states naturally provide [14] and which can be linked to surface codes [6,15].The main design tool upon which we base our construction are engineered lattice defects which are topologically entangled.
The picture is the following: quantum computation is performed on a three-dimensional cluster state via a temporal sequence of one-qubit measurements.The cluster lattice is subdivided into three regions, V , D and S. The set S comprises the 'singular' qubits which are measured in an adaptive basis.The quantum computation happens essentially there.The sets V and D are to distribute the correct quantum correlations among the qubits of S. V stands for 'vacuum', the quantum correlations can propagate and spread freely in V .D stands for 'defect'.Quantum correlations cannot penetrate the defect regions.They either end in them or wrap around them.In both cases, Figure 1: Topological error correction for the QC C .The three-dimensional cluster state, shown as a block, is structured by lattice defects which exist in two kinds: primal and dual.The defects wind around another.Some of them hold singular qubits (red) which realize the non-Clifford part of the quantum computation.
the defects guide the quantum correlations.V and D are distinguished by the bases in which the respective cluster qubits are measured.The region V fills most of the cluster.Embedded in V are the defects (D) most of which take the shape of loops.These loops are topologically entangled with another.Further, there are defects in the shape of ear clips which each hold an S-qubit in their opening.Such a defect and the belonging S-qubit form again a loop.These are the only locations where the S-qubits occur.See Fig. 1.
There are two codes upon which we base our construction, the planar code [15] and the concatenated [15,3,1] quantum Reed-Muller code [16,17].Both codes individually have their strengths and weaknesses, but they can be advantageously combined.The planar code has a relatively high error threshold of about 11% [18], and the symmetries of its stabilizer fit well with cluster states.Moreover, fault-tolerant data storage with the planar code and the creation of long range entanglement among planar code qubits are easily accomplished in three-dimensional cluster states, via a bcc-symmetric pattern of one-qubit measurements.Therefore, it is suggestive to base fault-tolerant cluster state computation on this code.However, the planar code is not well suited to non-Clifford operations which are essential for universal quantum computation.Now, in cluster-and graph state quantum computation, the non-Clifford part of the circuit is implemented by destructive measurements of the observables (X ± Y )/ √ 2 (The Clifford part is implemented by X-, Y -and Z-measurements.).The Reed-Muller quantum code is well suited for fault-tolerant quantum computation via local measurements because the measurements of the encoded observables (X ± Y )/ √ 2 (and of X, Y , Z besides) are accomplished fault-tolerantly by the respective measurements on the bare level-and bare level measurements is what we are allowed to do in the QC C .If we could assume we had given a graph state state as algorithmic resource where each cluster qubit was encoded with the concatenated Reed-Muller code and where noise acted locally on the bare level, then fault-tolerant quantum computation were trivial to achieve.However, is not obvious how to create such an encoded graph state affected by local noise only.But this is just what the topological error correction in cluster states can do.This paper is organized as follows.In Section 2, we introduce the ingredients required for the error correction mechanisms we use, namely cluster states, the planar code and the 15-qubit Reed-Muller quantum code.In Section 3 the measurement pattern used for fault-tolerant cluster state quantum computation is described, and in Sections 5 -6 it is explained.Specifically, in Section 5 we describe the physical objects relevant for the discussed scheme-defects, cluster state quantum correlations, errors and syndrome bits-in the language of homology.In Section 6 we introduce the techniques for structuring quantum correlations via topological entanglement of lattice defects.Our error models are stated in Section 7.1 and the fault-tolerance threshold is derived in Section 7.2.The overhead is estimated in Section 8. We discuss our results in Section 9.

Cluster states and quantum codes

This section is a brief review of the ingredients for the described fault-tolerant QC C .
Cluster states.A cluster state is a stabilizer state of qubits, where each qubit occupies a site on a d-dimensional lattice C. Each site a ∈ C has a neighborhood N (a) which consists of the lattice sites with the closest spatial distance to a.Then, the cluster state |φ C is-up to a global phase-uniquely defined via the generators K a of its stabilizer
i.e., |φ C = K a |φ C .Here, X a and Z b are a shorthand for the Pauli operators σ (a)
x and σ
z that we use throughout the paper.We refer to the generators K a of the cluster state stabilizer as the elementary cluster state quantum correlations.
In this paper, we will use as the lattice underlying the cluster state a bcc-symmetric lattice in tree dimensions.That is, the location of cluster qubits is given by lattice vectors (
We sub-divide the set of qubits into two subsets, the even and the odd qubits.For even (odd) qubits the sum of the coordinates of their respective lattice site is even (odd).Note that instead of with a bcc-symmetric lattice we could have equivalently started with a cluster state on an sc-symmetric lattice, because a cluster state on the latter is mapped to a cluster state on the former by Z-measurements on the qubits (e, e, e) and (o, o, o); see [9].
The [15,3,1] quantum Reed-Muller code.By this we denote a 15 qubit CSS-code based on the (classical) punctured Reed-Muller code R(1, 4) * [19].Its stabilizer generator matrix has the form
where
and G Z is given by G X ⊥ = G Z ⊕ (1, 1, ..., 1, 1).This code has the fairly rare property that the encoded non-Clifford gate U z (π/4) = exp(−iπ/8Z) is local [16,17], i.e.,
This property has been used in magic state distillation [17].In the computational scheme described here we use it to fault-tolerantly measure the encoded observables X±Y √ 2 via local measurements of observables
Surface codes.For the surface codes [6,15] physical qubits live on the edges of a two-dimensional lattice.The support of a physical error must stretch across a constant fraction (typically 1/2) of the lattice to cause a logical error.The protection against errors is topological.
The stabilizer generators of the code are associated with the faces f and the vertices v of the lattice,
Therein, ∂ is the boundary operator.The number of qubits that can be stored depends on the boundary conditions of the code lattice.The code resulting from periodic boundary conditions, the 'toric code' [6], can store two qubits.
As an example we would briefly like to discuss the planar code [15] which encodes one qubit; see Fig. 3a.This example exhibits many features of our subsequent constructions one dimension higher up: Errors are identified with 1-chains and show a syndrome only at their end points.Homologically equivalent chains correspond to physically equivalent errors.Error chains can end in the system boundary without leaving a syndrome.Specifically, Pauli operators Z i live on the edges of the primal (=shown) lattice, and Pauli operators X j live on edges of the dual lattice.The encoded Z-operator is a tensor product of individual Z i operators corresponding to a primal 1-chain stretching from left to right across the code lattice.The encoded X-operator corresponds to a 1-chain of the dual lattice that stretches from top to bottom.
The code stabilizer is modified at the system boundary.For example, a face to the left or right of the lattice has only three elementary 1-chains in its boundary, instead of four.Such boundary is called a 'rough edge'.Where no modification of the faces occurs the system boundary is a 'smooth edge'.'Smooth' on the primal lattice is 'rough' on the dual, and vice versa.Error chains can end in a rough edge of their respective lattice without leaving a syndrome, but not in a smooth edge.The surface codes will occur rather implicitly in our constructions.The reason is that here we do not use such codes to encode logical qubits.Instead, we use them to appropriately "wire" a subset of the cluster qubits, the S-qubits.The link between surface codes and cluster states has been established in [14], for the purpose of creating long range entanglement in noisy 3D cluster states via local measurements.It has been found that the error correction implemented by the local measurements is described-like fault-tolerant data storage with the toric code-by the so-called Random plaquette Z 2 -gauge model in three dimensions (RPGM) [18].The three-dimensional cluster state is like a surface code, one dimension higher up.The third dimension, which is temporal in data storage with the toric code, is spatial for the cluster state.The extra spatial dimension can be used to fault-tolerantly mediate interaction among qubits.The creation of an encoded Bell state over large distances [14] is the simplest example.The long-range quantum correlations are engineered by the suitable choice of boundary conditions.Why are the above two codes chosen?For the fault-tolerant scheme of quantum computation described in this paper we require a quantum code with the following three properties: 1) The code is of CSS-type, 2) The code satisfies Eq. ( 5), and 3) The code fits with cluster states.For some arrangement of qubits on a translation-invariant two-dimensional lattice, the code has a translationinvariant set of stabilizer generators and these generators each have a small support on the lattice.
The Reed-Muller code has properties 1 and 2 but not 3.The surface codes have properties 1 and 3 but not 2. Thus, neither of the codes alone suffices.But their combination does, as is described in the subsequent sections.

The measurement pattern

As pointed out in the introduction, we subdivide the cluster C into the three disjoint subsets V , D and S. S is the the set of qubits where the non-Clifford part of the quantum computation is performed, and V and D are to connect the qubits of S in the proper way.We have not yet explained what the defects are, and we will do so only in the next section.For the moment it suffices to note that the defects are located on the subset D of the cluster, and that D is the union of the two disjoint subsets D 1 and D 2 .The measurement pattern on D, S and V is given by Defect qubits a ∈ D :
Measurement of
Vacuum qubits a ∈ V : Measurement of X a .
Now we have to explain why we choose this measurement pattern, which is best done using the language of homology.

Involving the Reed-Muller quantum code

In this section we explain the role of the Reed-Muller code for the described computational scheme.Consider a cluster state |φ C 2 on a two-dimensional cluster C 2 .It is a resource for universal quantum computation by measurements of the local observables X, Z and X±Y √ 2 , [9].Denote by Q ⊂ C 2 the set of qubits which are measured in the eigenbasis of X±Y √ 2 .These measurements implement the non-trivial part of a quantum circuit.The measurements of X and Z on the qubits C 2 \Q implement the Clifford part.They are performed simultaneously in the first round of measurements.|Ψ algo Q is the state of the unmeasured qubits after the first measurement round.It is an algorithm-specific stabilizer state, hence the subscript "algo".Since it is a stabilizer state, it is easy to create and one may start with this state as an algorithm-specific resource instead of the universal cluster state.Quantum computation with this state proceeds by measuring local observables X±Y √
2 .Now suppose an encoded version of this state, |Ψ algo S , was given.The state were not perfect but only affected by local noise on the bare level.Of course, a question that arises immediately is how such a state is obtained.The main part of work in this paper goes into answering this question, see subsequent sections.Now, with |Ψ algo S given, one could perform fault-tolerant quantum computation by fault-tolerant measurement of the encoded observables X±Y √ 2 .This is not what we have in mind, because we are seeking a scheme of fault-tolerant quantum computation by local measurements.Here lies the reason for involving the (concatenated) Reed-Muller code: For this code, the fault-tolerant measurement of the observables X±Y √ 2 proceeds by local measurements of observables X±Y √ 2 .The reason for this is property (5).If J is a set such that g X (J) := j∈J X j is in the RM code stabilizer, then also
The relevant encoded observables are given by
The "∓" is for the total number of concatenation levels being odd.If the number is even, replace "∓" by "±".Therefore, if all the bare qubits belonging to an encoded qubit are individually measured in the eigenbasis of
2 , then the eigenvalue found in a measurement of the encoded observable X+Y √ 2 and the eigenvalues of the stabilizer generators g + (J) can be deduced from the individual measurement outcomes.This is all what is needed for fault-tolerant measurement of the encoded observable X+Y √ 2 .
The Z-part of the code stabilizer is lost in the local measurement, but it is not needed for the fault-tolerant measurement of X±Y √ 2 .This can be seen as follows.For simplicity assume a local depolarizing error p/3
for all qubits j.The brackets "[•]" indicate a super-operator.W.l.o.g.assume that the local measurements are in the eigenbasis of
Then, the error
is absorbed in the measurement and has no effect.
The second error
so all remaining errors are equivalent to Z-errors.Such errors are identified by the stabilizer elements {g + (J)}.
To summarize, the Reed-Muller code is involved to perform the fault-tolerant measurement of the encoded observables locally on the bare level.The eigenvalues corresponding to the encoded observable and to the relevant stabilizer generators are simultaneously inferred from the measurement outcomes.Error correction proceeds by classical post-processing of these quantities.

Involving a topological quantum code -Homology

The remaining question is how we actually create the state |Ψ algo S with only local error from a three-dimensional cluster state.To accomplish this task we involve topological error correction.

Errors and correlations as chains

The physical objects of our discussion-cluster state correlations and error operators-may be identified with faces and edges of an underlying lattice.Compositions of such faces or edges are called 2-chains and 1-chains, respectively.For the chains homology provides an equivalence relation; namely, two chains are homologically equivalent if they differ by the boundary of a third chain one dimension higher up [20,21,22].Homology plays a role in our constructions because homological equivalence of the underlying chains implies physical equivalence of the associated physical objects.
First we introduce the two simple cubic sub-lattices L and L whose vertices are at locations
One lattice can be obtained from the other via translation by a vector (±1, ±1, ±1).L and L are dual to another in the sense that the faces of L are the edges of L, the cubes of L are the vertices of L, and vice versa.We denote by * the duality transformation that maps primal edges into the corresponding dual faces ( * e = f ), and so forth.We denote by B(C 0 ) := {v k } the set of vertices in L, by B(C 1 ) = {e l } the set of edges in L, by B(C 2 ) = {f m } the set of faces in L, and by B(C 3 ) = {q n } the set of elementary cells [or cubes] of L. We may now define chains in L [20].B(C 0 ) forms a basis for the set C 0 of so called 0-chains c 0 , B(C 1 ) forms a basis for the set C 1 of 1-chains c 1 , and so forth.Specifically, the chains are given by
where z k , z l , z m , z n ∈ Z 2 .The sets C 0 , C 1 , C 2 and C 2 are, in fact, abelian groups under componentwise addition, e.g.
is called a chain complex, and ∂ is called boundary operator.It maps an i-chain c i to its boundary, which is an i − 1-chain.In the same way, L can be defined as a dual chain complex, [20].Of interest for topological error-correction is the notion of relative homology.Consider a pair of spaces (C, D) with [21].Relative cycles may end in D.
Below we describe how the cluster state quantum correlations may be identified with the 2chains, the errors with the 1-chains and the syndrome with the 0-chains of L and L. All these objects appear in two kinds, 'primal' and 'dual', depending on whether they are defined with respect to L or L.
Cluster state correlations.We define primal such correlations, K(c 2 ), and dual ones, K(c 2 ), which can be identified with 2-chains in L and L, respectively, by
Therein, e.g. the set
Errors.We will mainly discuss (correlated) probabilistic noise.Then, it is sufficient to restrict the attention to Pauli phase flips Z, because X a ∼ = b∈N (a) Z b etc.We combine Z-errors on odd (even) qubits to primal (dual) error chains E(c 1 ) (E(c 1 )),
Syndrome.The first type of correlations we discuss are those for error correction in V .They are characterized by the property that the corresponding 2-chains have no boundary.I.e., we consider K(c 2 ), K(c 2 ) with {c 2 }, {c 2 } ∈ V and ∂c 2 = ∂c 2 = 0.With (13), these correlations take the form
. They are measured by the X-measurements in V , see (7), and are used to identify errors occurring on the qubits {c 2 }, {c 2 }.The group of 2-chains in the kernel of ∂ we denote by Z 2 (L).Since ∂∂ = 0, a subgroup of those, B 2 (L), is formed by the 2-chains which are themselves a boundary of a 3-chain.Denote by q (q) a 3-chain from the basis B(C 3 ) (B(C 3 )).It represents an individual cell [or cube] of the primal lattice L (dual lattice L).The associated quantum correlations are
When being measured, each of these correlations yields a syndrome bit Sy(q), Sy(q) which, we say, is located at q or q, respectively.Because the lattices L and L are dual to another, we may identify the cell q in L with a vertex v in L, and vice versa.In this way, the syndrome bits become located at vertices of the lattices L and L. The syndrome resulting from the quantum correlations ( 16) are those which enable topological error correction [18].
Syndrome and errors.Let E(c 1 ) denote a primal error chain, q ∈ B(C 3 ) a cell in the dual lattice L and v ∈ B(C 0 ) = * q.K(q) detects the error E(c 1 ) if |{c 1 } ∩ {∂q}| = odd.Equivalently, K(q) detects E(c 1 ) if v ∈ {∂c 1 }.Thus, error chains show a syndrome only at their ends.
Correlations and errors.Primal cluster state correlations are affected by dual error chains and dual correlations are affected by primal error chains.Primal correlations are not affected by primal error chains, and dual correlations are not affected by dual error chains.
To see this, note that a primal correlation K(c 2 ) consists of Pauli operators X on even qubits and Pauli operators Z on odd qubits.A dual error chain E(c 1 ) consists of operators Z on even qubits.Then,
) by the error.If it is even, then the correlation remains unchanged.This situation has a geometric interpretation.|{c 1 } ∪ {c 2 }| is the number of intersection points between the primal 2-chain c 2 and the dual 1-chain c 1 .If the number of intersections is odd (even) then the correlation is (is not) affected by the error.For dual correlations and primal errors the situation is the same.Further, a primal error chain consists of Pauli operators Z on odd qubits.Thus,
Defects.The purpose of defects is to structure the space underlying the pair of lattices L, L. Practically, a defect can be thought of as a set of qubits that are removed from the initial cluster C before the remaining qubits are entangled.For the chain complexes C, C, a defect is a set d of missing edges.What defines a defect as an entity is that the belonging edges are connected.As all the other objects, defects are either primal or dual,
The sets d, d of defect qubits are not arbitrary.Seen from afar they take the shape of doughnuts.These doughnut-shaped defects will be topologically entangled with another, and the way they are entangled encodes the quantum algorithm to be performed.From the viewpoint of quantum logic, what matters about the doughnuts is that they are loops.Their 'thickness' is required for fault-tolerance.We now briefly explain how the above definition of a defect as a set of missing cluster qubits fits with the measurement pattern (7).Formally, each defect d will be assigned a set D(d) of locations on the cluster.This set is subdivided into a set of edge-and a set of face qubits, D 1 (d) and D 2 (d).
Here, the notions of 'edge' and 'face' are in reference to the lattice the defect belongs to.If the defect is primal (dual) then the edges and faces are taken with respect to the primal (dual) lattice.For primal defects, the sets D 1 (d) and D 2 (d) are defined as
For dual defects, replace f by f and C 2 by C 2 in the above definition.The whole defect region D splits into an edge part D 1 and a face part
Now the measurement pattern (7) becomes understandable: the edge qubits in the defects are measured in the Z-basis which effectively removes them from the cluster [10].In this way, the quantum state on the exterior of the defect becomes disentangled from the state with support on interior of the defect.Thereby, a defect is created in the cluster lattice.Note that the qubits on faces whose entire boundary is in D 1 (d) become disentangled individually.If no errors were present we could leave these qubits alone.However, their measurement in the X-basis provides additional syndrome and so it is advantageous to measure them.
Correlations and defects.In the proximity of a primal defect, edges in the boundary of a primal 2-chain are removed, see (17).Therefore, primal correlations can end in primal defects.Syndrome and defects.In the presence of a primal defect d the correlations {K q = K(∂q)| q ∈ B(c 3 ) ∧ ∂q ∩ d = ∅} do not commute with the measurements (7), such that the syndrome at the locations
is lost.Note, however, that for each defect d there will be one syndrome bit associated with the defect as a whole.There exists a 2-cycle c 2 (d), {c 2 (d)} ⊂ V , that wraps around d, and
. When the qubits in V are measured in the X-basis, this correlation yields an additional syndrome bit.Dual defects act analogously on the dual lattice.
Errors and defects.Because the local syndrome is lost at the surface of a defect, primal error chains can potentially end in primal defects.However, there is a dual correlation
wrapping around a primal defect, and this correlation detects a primal error chain E(c 1 ) if the number of intersection points between c 2 (d) and c 1 is odd.Thus, primal error chains can pairwise end in primal defects.Primal error chains cannot end in dual defects, because dual defects do not remove primal syndrome.Similarly, dual error chains can pairwise end in dual defects, and they cannot end in primal defects.
The relations among cluster state correlations, errors and defects are summarized in Tab. 1.

Homological and physical equivalence

We have so far identified physical objects-correlations and errors-with chains of a chain complex.In this section we point out that it is the homology class of the chain rather than the chain itself which characterizes the respective physical object.The equivalence of two chains under relative homology implies the physical equivalence of the corresponding physical operators.
1. Cluster state correlations.We regard two cluster state correlations K(c 2 ), K(c ′ 2 ) as physically equivalent if they yield the same stabilizer element for the state |Ψ algo S after the measurement of the qubits in V and D. This requires two things.First, K(c 2 ) and K(c ′
2 ) need to be simultaneously measurable.With O a the locally measured observables (7) we require
Second, the two operators must agree on S, K(c
), (*) and (**) imply simultaneous measurability of K(c 2 ) and K(c ′ 2 ) on V ∪ D. 2. Same restriction to S: K(∂c 3 ) and K(γ 2 ) don't act on S, hence
2. Errors.Two errors E(c 1 ) and E(c ′ 1 ) are physically equivalent if they cause the same damage to the computation.That is, they have the same logical effect and leave the same syndrome.Then, the following statement holds:
. Now, a Pauli spin flip error X is absorbed in a subsequent X-measurement and has no effect on the computation, I±X 2 X = ± I±X 2 I. Thus, with (7),

Constructive techniques

The purpose of the measurements in V and D is to create on S the Reed-Muller-encoded algorithmspecific resource |Ψ algo S described in Section 4. In Section 6.1, we specify the location of S-qubits with respect to the lattice defects and then, in Section 6.2, we give a construction for a topologically protected circuit providing |Ψ algo S .

Location of the S-qubits

The S-qubits have very particular locations within the cluster.Besides the defects in the shape of doughnuts that we have already introduced the cluster also supports defects shaped like ear clips.The opening of these ear clip defects is only one cluster qubit wide.If this one cluster qubit were a defect qubit (q ∈ D) too, the ear clips would become doughnuts.But the particular cluster qubit is not in D, it is an S-qubit.The situation is displayed graphically in Fig. 4a.
The appropriate stabilizer generators among the S-qubits are induced from the cluster state correlations associated with relative 2-cycles, by measurement of the V -and D-qubits.As everything else in this computational scheme, the S-qubits occur in the two kinds 'primal' and 'dual'.We call an S-qubit q primal, q ∈ S p , if it lives on the a face of the primal lattice, and we call it dual, q ∈ S d , if it lives on a face of the dual lattice.
We now discuss how primal and dual correlations affect the S-qubits.Consider, for example the correlation K(c 2 ) corresponding to a primal relative 2-chain c 2 .A primal S-qubit at location q may lie within c 2 , but never in its boundary, {∂c 2 } ∩ q = ∅.A dual S-qubit q ′ may lie in the boundary of a primal 2-chain c 2 but never in c 2 itself, {c 2 } ∩ q ′ = ∅.We therefore conclude that A primal correlation K(c 2 ) acts on a primal S-qubit by one of the two Pauli-operators X, I and on a dual S-qubit by one of the two operators Z, I.A dual correlation K(c 2 ) acts on a primal S-qubit by one of the two Pauli-operators Z, I and on a dual S-qubit by one of the two operators X, I.
For finding the extended relative 2-cycles on the primal lattice, we thus regard S p as part of V and S d as part of D. Analogously, for finding the extended relative 2-cycles on the dual lattice, we regard S p as part of D and S d as part of V .In this way, the problem of finding the extended primal 2-cycles on a cluster with S-qubits is reduced to the same problem without S-qubits.

Creating |Ψ algo among the S-qubits

The construction of a topologically protected circuit providing |Ψ algo S proceeds in three steps.First we show that |Ψ algo S is local unitarily equivalent to a bi-colorable graph state, by local Hadamard-transformations.Second, we show how to create a bi-colorable graph state.Third, we take care of the Hadamard-transformations.
and has the form
Then, with (22) and
Thus, also the state |Ψ algo is l.u.equivalent to a CSS-state,
Now, we consider the concatenated-Reed-Muller-encoded resource |Ψ algo S , which may obtained from the bare state |Ψ algo Q via encoding, |Ψ algo S = q∈Q Enc q |Ψ algo Q .The encoding procedure Enc takes every qubit q ∈ Q to a set S(q) of qubits, q∈Q S(q) = S.It has the property that Enc q • H q = i∈S(q) H i • Enc ′ q .Therein, Enc ′ is an encoding procedure for the code conjugated to the Reed-Muller-code, i.e., for the code with the X-and the Z-block of the stabilizer interchanged.This code is of CSS type, like the Reed-Muller code itself.The encoding procedure changes when passing through the Hadamard-gate because the encoded Hadamard-gate is not local for the Reed-Muller quantum code.
At any rate, the state |Ψ algo S is l.u.equivalent to a CSS-state encoded with CSS-codes, i.e., to a larger CSS-state, |Ψ algo S = q∈C odd ∩Q i∈S(q) H i |CSS ′′′ S .Every CSS-state is l.u.equivalent to a bi-colorable graph state [23], by a set of local Hadamard-transformations.Thus, we finally obtain
Therein, S H is some subset of S and |Γ S is a bi-colorable graph state with adjacency matrix of the corresponding graph
dual primal 0 Circuit for a bi-colorable graph state.The circuit layout for the topologically protected creation of an arbitrary bi-colorable graph state is shown in Fig. 5.The circuit consists of a set of horizontal primal and a set vertical dual defects.Each primal defect comes close to each dual defect once, and the two defects may be linked in that region.The form of this junction is decided by a corresponding element of the graph state adjacency matrix G.If G i,j = 1 then the defects are linked and otherwise they are not.In addition, each of the loop defects is linked with an ear-clip shaped defect which holds an S-qubit.The graph state in question is formed among these qubits after the remaining qubits have been measured.
An explanation of the circuit in Fig. 5, for the specific example of a line graph, is given in Fig. 6.From this example it should be clear how the circuit works in general.For the line graph we have the adjacency sub-matrix only edges of the line graph ending in the vertex b.For every edge in the graph there is a link among defect loops in the circuit.
The proof for the programmable circuit of Fig. 5 realizing a general bi-colorable graph state is similar.As an outline, each stabilizer generator is associated with a doughnut-shaped defect in the circuit.Such a defect bounds a correlation, and this correlation affects one S-qubit by X. Further, because the considered defect is linked with other defects of the opposite kind, the correlation surface forms tubes.These tubes affect one other S-qubit each-the neighbors of the first-by Pauli-operators Z.
Implementing the local Hadamard-transformations.The equivalence between the graph state |Γ S and the encoded algorithm specific resource |Ψ algo S is by Hadamard-transformations on some subset S H of S-qubits.Wherever such a Hadamard-transformation needs to be applied, attach an extra loop to the circuit in Fig. 5,
7 Error sources, error correction and fault-tolerance threshold

Two error models

Below we describe two error models, a simple one and a more realistic one.
Error Model 1.The cluster state is created only on those cluster qubits which are needed for the computation, i.e., on V ∪ S. The defect qubits of D are left out.
1.The noise is described by independent partially depolarizing channels acting on each cluster qubit.The noisy state ρ C is given by ρ C = a∈C T a (p 1 ) |φ C φ|, with

The classical computation for syndrome processing is instantaneous.

The reason for considering this error model first is its simplicity.We would like to separate the intricacies inherent in the presented error-correction scheme from additional difficulties incurred by a realistic error model.The basic justification for such an approach is this: The error correction used here is topological.Therefore, a threshold should exist regardless of whether independent errors are strictly local or only local in the sense of having a support of bounded size.
The most straightforward method to create a cluster state is from a product state a |+ a via a (constant depth) sequence of Λ(Z)-gates [10].If these gates are erroneous, then Error Model 1 does not apply in general. 1 Specifically, one may raise the following objections to Error Model 1:
• No correlated errors are included in Error Model 1. Creating the cluster state via a sequence of gates will, however, lead to correlated errors in the output cluster state.

• Storage errors accumulate in time.

There is temporal order among the measurements such that the computation takes a certain time t comp which cannot be bounded by a constant for all possible computations.As a consequence, for the qubits measured in the final round the local noise rate increases monotonically with t comp and exceeds the error threshold.
• To leave the D-qubits out is a deviation from the originally envisioned setting: the cluster state on S ∪ V is algorithm-specific. 2  To account for these inadequacies, we consider a second error model.
Error Model 2. A cluster state on a bcc-symmetric lattice is created in four steps of nearestneighbor Λ(Z)-gates.The gate sequence is as shown in Fig. 7. Errors occur due to the erroneous preparation of the initial |+ -qubits, erroneous Λ(Z)-gates in the process of creating the cluster state, storage and measurement.
1.The computation is split up into steps which performed on sub-clusters C k .In each step, unmeasured qubits remaining from the previous step-the hand-over qubits-are loaded into a cluster state on a sub-cluster.Subsequently, all but a few cluster qubits (the new hand-over qubits) are measured.The steps have their temporal depth adjusted such that each qubit, after being locally prepared and entangled, waits at most a constant number t 0 of time steps until its measurement occurs, t 0 ≥ 1. Error in storage is described by a partially depolarizing noise with error probability p S per time step.

The erroneous preparation of initial |+

-qubits is modeled by the perfect procedure followed by local depolarizing noise (28), with probability p P .Measurement is described by perfect measurement preceded by partially depolarizing noise with error probability p M .The erroneous Λ(Z)-gates are modeled by the perfect gate followed by a 2-qubit depolarizing channel

Classical syndrome processing is instantaneous.

1 There may be situations in which the error Model 1 is in fact a good approximation.For example, consider a scenario in which the cluster state is purified before being measured for computation.Of course, the gates in a purification protocol would be erroneous, too, such that the purified state is not perfect.In effect, the errors of the initial state were replaced by the errors of the purification protocol.There exist purification protocols [24] in which the gates act transversally on two copies of the cluster state (one of which is subsequently measured).As a result, the errors introduced by the purification are approximately local, as in Error Model 1.The purification protocol [24] in its current form has a problem of its own, though; due to the exponentially decreasing efficiency of post-selection, it is not scalable in the size of the state.But chances are that this can be repaired.
2 For the creation of the cluster state this makes little or no difference: fewer gate operations are needed than for the creation of |φ C .For parallelized procedures that make use of the translation invariance of C, it should not be too difficult to remove the superfluous D-qubits from the lattice before the remaining qubits are entangled.
Step 1
Step 2
Step 3
Step 4
Figure 7: Steps of Λ(Z)-gates for the creation of a cluster state on a bcc-symmetric lattice, for the sub-clusters C k .For k odd, the sequence is 1 → 2 → 3 → 4, and for k even it is 3 → 4 → 1 → 2.
In the subsequent sections we compute a fault-tolerance threshold for both error models.In Error Model 2, storage error will cause the minimum damage for the smallest possible value of t 0 , which is t 0 = 1.In this case, each sub-cluster carries a subset of S-qubits with no mutual temporal dependence.All qubits in V and D, except the hand-over qubits (See Appendix A), are measured immediately after being entangled.The measurement of the S-qubits has to wait one time step.Henceforth we set t 0 = 1.

Methods for error correction and the threshold value

There are different methods of error correction associated with the different regions V , S and D of the cluster.In D, there are as many inequivalent errors as there are syndrome bits, such that the error correction is trivial.The error correction in V is based on the random plaquette Z 2 -gauge model in three dimensions [18].The error correction in S is carried out using the (concatenated) quantum Reed-Muller code.
Error correction in D. In the domain D(d) of the defect only Z-errors matter for face qubits and only X-errors matter for edge qubits.Any other errors may be absorbed into the subsequent measurements (7).The X-errors on edges may be relocated to Z errors on the neighboring face qubits via X e ∼ = K e X e , such that we need to consider Z-errors on face qubits only.For each face in d we learn one syndrome bit, yielding a unique syndrome for each error configuration.
However, if an error X e on an edge qubit e in the surface of defect d is relocated, the equivalent error K e X e may partially be outside D(d).After error correction in D(d), an individual Z-error on a face qubit in V is left next to D(d).This affects the error correction in V near D; see below.
Error correction in V .First consider a scenario where the entire cluster consists of the region V (i.e., there are no defects and no singular qubits).Error correction on the primal lattice L and the dual lattice L run separately.Here we consider error correction on the primal lattice only; error correction on the dual lattice is analogous.
The error chains live on the edges of the lattice L and leave a syndrome at the end points, which are vertices of L. This is exactly the scenario which has been considered for topological quantum memory in [18], and subsequently the results of [18] that we need in the present context are briefly summarized.The connection between topological error correction and cluster states has been made in [14] for the purpose of creating long-range entanglement in the presence of noise.
Given a particular syndrome and an error chain E(c 1 ) compatible with this syndrome, we are interested in the total probability P (c 1 ) of the homology class of c 1 ,
where p(c ′ 1 ) is the probability of an individual error chain E(c ′ 1 ), and the sum is over all 1-cycles.
For error correction we infer that the physical error which occurred was from the homology class with the largest probability.
If the errors on the lattice edges occur independently with a probability q then the problem of computing P (c 1 ) for a given chain c 1 can be mapped onto a problem from statistical mechanics, namely the random plaquette Z 2 -gauge model in three dimensions [18].The crossover from high fidelity error correction at small error rates to low fidelity error correction at high error rates corresponds to a phase transition in this model.A numerical estimate of the critical error rate is q c = 0.033 ± 0.001 [25].
As far as is known, the classical operational resources required to find the most likely error homology class consistent with a given syndrome scales exponentially in the number of error locations.The assumption of the classical processing being instantaneous cannot be justified under these conditions.However, it is possible to trade threshold value for efficiency in the error correction procedure.A reasonable approximation to the maximum probability for a homology class of errors is the probability of the lowest weight admissible chain.The minimum-weight perfect matching algorithm [26,27] computes this chain using only polynomial operational resources.A numerical estimate to the threshold with this algorithm for error correction is q ′ c = 0.0293 ± 0.0002 [28].Remark: The topological error threshold is estimated in numerical simulations of finite-size systems.For this purpose, the probability of logical error is plotted vs. the physical error parameter for various system sizes.For sufficiently large lattices (such that finite-size effects are small), we expect these curves to follow a universal scaling ansatz near the threshold such that they share a common intersection point and their slopes are proportional to a common power of the lattice size.As the system size is increased to infinity, we then expect the curves to approach a step function which transitions at the threshold value of the physical error parameter.
The above quoted threshold value is for independent errors on the edges of L. Do the models for the physical error sources of Section 7.1 lead to such independent errors?The answer is 'yes' for error Model 1 and 'no' for error Model 2. For the latter, we need to consider a modified RPGM with correlated errors among next-to-nearest neighbors.Specifically, for Error Model 1 the relation between the local rate p 1 of the physical depolarizing error and the error parameter q that shows up in the RPGM is
Given a threshold of q = 2.93% [28] for error correction via the minimum weight perfect matching algorithm in the bulk, then the corresponding depolarizing error rate that can be tolerated is
For Error Model 2, first consider the case where only the Λ(Z)-gates are erroneous, p P = p S = p M = 0.Then, in addition to local errors with a rate q 1 there exist correlated errors with error rate q 2 for each pair of opposite edges in all faces of L. That is, with a probability q 2 simultaneous errors are introduced on opposite edges of the faces in L. The local noise specified by q 1 and the two-local noise specified by q 2 are independent processes.The relations between the error parameter p 2 of the Λ(Z)-gates and the parameters q 1 , q 2 of the RPGM with correlated errors are  The only effect of p P , p S , p M > 0 is an enhanced local error rate q 1 .We give the relations to leading order only; they read
See Fig. 8 for a simulation of error correction under faulty Λ(Z)-gates as the only error source, which gives rise to correlated noise between neighboring edge qubits.If we define x = (p 2 − p 2,c )L 1/ν 0 then the universal scaling ansatz states that fidelity F should be a function dependent only on the scaling parameter x in the vicinity of the threshold [28].We find very good agreement (with R 2 > .9991)for F = A+ Bx+ Cx 2 , where we fit for constants A, B, C, p 2,c , and ν 0 .This gives very tight bounds on the critical probability p 2,c = 9.6 × 10 −3 .Interestingly, we also find ν 0 = 1.00 ± 0.02, which indicates that this model belongs to the same universality class as the purely local error model of the 3D-RPGM [28].In Fig. 9 the threshold trade-off curve between p P + p S + p M and p 2 is displayed.Numerically, we obtain for the thresholds in the bulk
for p 2 = 0, p 2 = 0.96 × 10 −2 , for p P = p S = p M = 0, p i = 0.58 × 10 −2 , for p P = p S = p M = p 2 .
(
Error correction in V near D. In the presence of defects there are two modifications to error processes in V .First, the length scale for the minimum extension of a non-trivial error cycle shrinks.Second, there is a surface effect; the effective error rate for qubits in V next to the surface of defects is enhanced by a constant factor.1. Length scale for non-trivial errors: For comparison, consider a cluster cube of finite size 2L × 2L × 2L.A non-trivial error cycle must stretch across the entire cube and thus has a weight of at least L. The lowest weight errors which are misinterpreted by the error correction procedure occur with a probability q L/2 .The total error probability incurred by such errors may therefore be expected to decrease exponentially fast in L, which is confirmed in numerical simulations [14].
In the presence of defects, the dominant sources for logical error are 1-chains that either wind around a defect or that begin and end in a defect and intersect a correlation surface (2-chain) in between; see Fig. 10.The relevant length scales are thus the thickness (circumference) and the diameter of the defects.They are much smaller than L.
Specifically, consider a defect with circumference u and length l which bounds a correlation surface c 2 , such that |{∂c 2 }| = l.An error cycle winding around the defect has a weight of at least u + 8 ≈ u, and there are l such minimum weight cycles.Therefore, the probability p E (u, l) for affecting K(c 2 ) by an error is, to lowest contributing order,
In the range of validity for the above expansion in powers of q, the error is still exponentially suppressed in the relevant length scale u.
2. Surface effects: As discussed above, the error level is enhanced for qubits in V near the surface of a defect.If the defect is primal (dual), the enhancement occurs on dual (primal) qubits.This effect will-if anything-lower the threshold.But there is another effect: the presence of the defect changes the boundary conditions.In case of a primal defect, the boundary conditions on the defect surface become rough for the primal lattice and smooth for the dual lattice.Dual error chains cannot end in a primal defect, as we noted earlier.For the dual lattice, there is excess syndrome available at the defect surface.This effect will-if anything-increase the threshold.Our intuition is that neither effect has an impact on the threshold value.The threshold should, if the perturbations at the boundary are not too strong, still be set by the bulk.
We have performed numerical simulations for lattices of size L × L × 2L, where half of the lattice belongs to V and the other half to the defect region D. The error rate is doubled near the mutual boundary of the regions and there is no remaining error in D. Simulations are feasible with reasonable effort up to L ≈ 20.We find that finite-size effects (due to the smooth boundary conditions) are still noticeable up to these lattice sizes, but the intersection point of fidelity curves for nearby lattice sizes is slowly converging to a threshold value around that of the bulk (∼ 2.9%).
Error correction in V near a junction between D and S. Near an S-qubit there exist relative error cycles of small length, see Fig. 11a, and the topological error correction breaks down.As a result, the effective error on an S-qubit is enhanced by its surrounding.To compute the effective error probabilities, we replace every low-weight error-chain E(γ) that results in a logical error after error correction by an equivalent error E S (γ) acting on the S-qubits.The error correction converts E(γ) into E(c 1 (γ)) with c 1 (γ) a relative 1-cycle.'Equivalent' means that E(c 1 (γ)) and E S (γ) act in the same way on the stabilizer generators {K Ψ,s | s ∈ S} of the induced state |Ψ algo S , i.e., [E(c 1 (γ))E S (γ), K Ψ,s ] = 0 for all s ∈ S. The relevant correlations to check are K(c 2 ) and K(c 2 ) displayed in Fig. 11a.
It is important to note that the effective error on the S-qubits is local.This arises because only error chains causing a 1-qubit error may have small length.Error chains causing a correlated error on the S-qubits are suppressed exponentially in the qubit separation.See Fig. 11b.
We compute the effective error channel on the S-qubit to first order in the error probabilities only.For error Model 1 the error enhancement only affects sub-leading orders of p 1 ,

Discussion

We have described a scheme for fault-tolerant cluster state universal quantum computation which employs topological error correction.This is possible because of a link between cluster states and surface codes.In addition to the topological method, we make use of a Reed-Muller quantum code which ensures that non-Clifford operations can be performed fault-tolerantly by local measurements.The error threshold is 1.4% for an ad-hoc error model with local depolarizing error and 0.11% for a more detailed error model with preparation-, gate-, storage-and measurement errors.We have not tried to optimize for either threshold value or overhead here; the foremost purpose of this paper is to explain the techniques.With regard to a high threshold, the obvious bottleneck is the Reed-Muller code.The error threshold imposed by this code on the cluster region S is-depending on the error model-a factor of 3 to 5 times worse than the threshold obtained from the topological error correction in V .To increase the threshold one may replace this code by another CSS code with property (5) that has a higher error threshold, provided such a code exists.Alternatively, one may probe the Reed-Muller code in error detection, as in magic state distillation [17].The error detection threshold is 14%, which indicates that there is some room for improvement.
Part of the investigations in this paper are numerical simulations, and we would like to comment on their impact on the threshold value.Numerics are encapsulated only in the threshold estimate for topological error correction which is much higher than the overall threshold.Our final threshold estimate stems from the Reed-Muller code and is analytical.The old sub-cluster is displayed in blue, the new in black; "•"; hand-over qubits, "•": qubits within one sub-cluster.b) Temporal order of operations."P": |+ -preparation, "E1-E4": steps of parallel Λ(Z)-gates, M1, M2: measurement.the measurements on qubits within S ∩ C k , for all k.Then, the S-qubits wait for one time step in which a storage error may occur.
The hand-over qubits stay in the computation no longer than the other V -and D-qubits.They form two subsets, H 1 = A ∪ B; see Fig. 13a.The qubits in A are prepared at t = 0, entangled in time steps 1 to 4 and measured in at t = 5.They cause no change in the error model.
The qubits in B are not acted upon by a gate until time step 2 (since the potential interaction partner of step 1 isn't there yet), so they are prepared at time t = 1.The final interaction involving the B-qubits is in step 5, and they are measured in step 6. Between preparation and measurement, the B-qubits are in the computation for four time steps in each of which they are acted upon by a gate.No additional storage error occurs.There is one modification due to the B-qubits.The temporal order of Λ(Z)-gates involving the qubits b ∈ B is changed.As a result, the correlated errors on the edge qubits of the faces {c 2 } = b are not among pairs of opposite edge qubits but among pairs of neighboring edge qubits.So, the error rates q 1 and q 2 in (34) are unchanged, but q 2 characterizes a slightly different process.
We expect this to be a minor effect.The overall threshold is still set by the threshold for Reed-Muller error-correction, which is some five times smaller than the simulated threshold for topological error correction.

B Effective error channel on the S-qubits

The effective error on an S-qubit stems from the S-qubit itself and its immediate surrounding shown in Fig. 14 and from the two edge-qubits in the one-dimensional section of the defect, which are not protected by any syndrome.Of the latter each contributes an error
The preparation error does not contribute, because the corresponding Z-error on the defect qubit is absorbed in the Z-measurement.
The effective error of the center qubit s ∈ S stems from operations that act on s directly, from X-or Y -errors propagated to s by the Λ(Z)-gates and from short nontrivial cycles.Specifically, there are four non-trivial cycles of length 3.One of them is denoted as E(c 1 ) in Fig. 14.Because of the correlations in the forward-propagated errors these cycles have weight 2 and cause inconclusive syndrome at lowest order in the error probability.There are further error cycles of length 3, such as E(c ′ 1 ) in Fig 14 .But they have weight 3 even for Error Model 2 and do not contribute to the lowest order error channel.We perform a count including all error sources in the cluster region displayed in Fig. 14, right.There is one convention that enters into the count.Namely, the error Z a Z b Z c Z d (see Fig. 14) is a non-trivial error cycle such that the errors Z a Z b and Z c Z d have the same weight and the same syndrome but different effect on the computation, X s vs.I s .When the corresponding syndrome occurs, we assert that a logical X-error occurred and correct for it.We obtain
The sources ( 46) and ( 47) combined, E central + 2 × E defect , lead to the local error channel (38).

C Conversion of Xand Y -errors on S-qubits

Here we show that an X-or Y -error on an individual S-qubit s with probability p is equivalent to a Zerror on that qubit with probability p/2, p[X s ] ∼ = p[Y S ] ∼ = p/2 [Z s ].The qubit s may be measured in the eigenbasis of X+Y √ 2 or of X−Y √ 2 .W.l.o.g.assume the qubit s is measured in the eigenbasis of X+Y √ 2 .Then, X s = Xs+Ys √

{

(o[dd], e[ven], e), (e, o, e), (e, e, o)}, odd qubits, {(e, o, o), (o, e, o), (o, o, e)}, even qubits.

1 Figure 2 :

Figure 2: Elementary cell of the bcc lattice.Qubits live on the faces and edges of the elementary cell.Syndrome bits are located in the cube and on the sites.Each elementary cell has a volume of 2 × 2 × 2 in cluster units.Black: elementary cell of the bcc lattice, blue: edges of the cluster graph.

Figure 3 :

Figure 3: Codes.a) Planar code.The encoded Pauli observables X and Z, two errors and the different boundary types 'smooth' and 'rough' are shown.The errors E X , E Z end in their respective rough boundary.E X corresponds to a trivial 1-cycle on the dual lattice and has no effect on the encoded state.E Z corresponds to an non-trivial 1-cycle on the primal lattice.It leaves no syndrome but causes a logical Z-error.b) Bi-colorable graph state locally unitary equivalent to the |+ -state of the 15-qubit quantum Reed-Muller code.

Figure 4 :

Figure 4: a) Location of a singular qubit (dual, held by a primal defect).b,c) The correlations K, K affect the S-qubit by a Pauli-operator X in (b), and by Z in (c).

Section 4 .

Denote by C X , C Z the subsets of C 2 \Q whose qubits are measured in the X-or Z-basis, respectively.Further, denote by C even , C odd the sets of even and odd qubits in C 2 (checkerboard pattern).The state |Ψ C 2 is given by

Figure 5 :

Figure 5: Creation of an arbitrary bi-colorable graph state.The singular qubits are displayed as red circles.G denotes the sub-matrix of the adjacency matrix Γ which encodes the edges between primal and dual vertices.

)Figure 6 :

Figure 6: Explanation of the circuit in Fig. 5 for a particular example, the line graph.a) The relative 2-cycle c 2 (b) which gives rise to the graph-state stabilizer K b = Z a X b Z c .b) Graph corresponding to the created graph state.

Figure 8 :

Figure8: Threshold estimation in lattices of finite size, for periodic boundary conditions.Here, with Λ(Z)-gates as the only error source, we find a threshold of p 2,c = 9.6 × 10 −3 .In the inset, best fits to the universal scaling ansatz are drawn.Error bars denote two standard deviations due to finite sampling size.

Figure 10 :Figure 11 :

Figure 10: Sources for logical error in the presence of defects.

Figure 13 :

Figure 13: Connecting sub-clusters.a) Elementary cell of L.The old sub-cluster is displayed in blue, the new in black; "•"; hand-over qubits, "•": qubits within one sub-cluster.b) Temporal order of operations."P": |+ -preparation, "E1-E4": steps of parallel Λ(Z)-gates, M1, M2: measurement.

Figure 14 :

Figure 14: Lattice around an S-qubit.Left: Location of the S-qubit (red) and the defect (gray).E(c ′ 1 ) is an error cycle of length 3 and weight 3 for Error Models 1 and 2. Right: Detail.E(c 1 ) is a non-trivial error cycle of length 3 which has weight 2 in error Model 2. Red: S-qubit, black: lattice L for topological error correction.The cluster edges (blue) correspond to Λ(Z)-gates whose temporal order is as indicated.

Table 1 :

This table shows who does what to whom.'A bounds B' is synonymous with 'B ends in A'.The displayed objects do not interact with themselves.
Dual defects do not remove primal edges, and thus primal correlations cannot end in dual defects.Analogously, dual correlations can end in dual defects, but not in primal defects.
The correlation of errors on sites separated by a distance of two arises through error propagation in the creation of the cluster state.Correlations among errors on next-neighboring sites play no role because such errors live on different lattices (L and L) and are corrected independently.
Figure 9: Trade-off curve for the threshold value in the presence of local and two-local errors.Horizontal axis: two-qubit gate error p 2 , vertical axis: local error rate p P + p S + p M .
